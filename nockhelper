#!/bin/bash

set -e

# MINING_PUBKEY to be used in the nockchain command
MINING_PUBKEY="2cLQ54ec6Caq9C4mTZoSk2Kv4XjJ3vzhyDehgdvEQue6dXZPp9jAa2ZqsaJciB3ZZXomoCjGp53GiyVJNSx2KDn8ehmNGdWcqBsfosDCsAQLDSBW8KgaDDHL4ojiFMSMtHbc"

# Nockhelper version
NOCKHELPER_VERSION="1.1.0"

# Installation directory
INSTALL_DIR="$HOME/nockbin"
HELPER_SCRIPT="$INSTALL_DIR/nockhelper"
HELPER_REMOTE="https://raw.githubusercontent.com/sarkrui/nockchain-auto/refs/heads/master/nockhelper"

# OS-specific system bin directory
SYS_BIN_DIR=""
if [[ "$OSTYPE" == "darwin"* ]]; then
    SYS_BIN_DIR="/usr/local/bin"
else
    SYS_BIN_DIR="/usr/bin"
fi

# Environment variables for nockchain
NOCKCHAIN_ENV_VARS="export RUST_LOG=\"info,nockchain=debug,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info\" && export MINIMAL_LOG_FORMAT=\"true\""

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to apply colors to text
print_colored() {
    local color=$1
    local text=$2
    echo -e "${color}${text}${NC}"
}

# Function to check and kill zombie nockchain processes
kill_zombie_processes() {
    local instance_id=$1
    local process_name="nock-$instance_id"
    
    # Collect all PIDs for the process (there could be multiple instances or child processes)
    local pids=($(pgrep -f "$process_name" || echo ""))
    
    if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
        print_colored "$YELLOW" "🔍 Zombie process(es) for $process_name detected after screen session ended."
        print_colored "$YELLOW" "Found ${#pids[@]} process(es) to terminate."
        
        # Try graceful termination first (SIGTERM)
        print_colored "$YELLOW" "🛑 Attempting graceful termination with SIGTERM..."
        for pid in "${pids[@]}"; do
            print_colored "$CYAN" "Sending SIGTERM to process $pid..."
            kill -15 "$pid" 2>/dev/null || true
        done
        
        # Wait a moment for processes to terminate
        sleep 2
        
        # Check if processes still exist and try SIGINT (like Ctrl+C)
        pids=($(pgrep -f "$process_name" || echo ""))
        if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
            print_colored "$YELLOW" "⚠️ Processes still running. Trying SIGINT (Ctrl+C)..."
            for pid in "${pids[@]}"; do
                print_colored "$CYAN" "Sending SIGINT to process $pid..."
                kill -2 "$pid" 2>/dev/null || true
            done
            
            # Wait again
            sleep 2
            
            # If still running, use force kill (SIGKILL)
            pids=($(pgrep -f "$process_name" || echo ""))
            if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
                print_colored "$RED" "⚠️ Processes still running. Forcing termination with SIGKILL..."
                for pid in "${pids[@]}"; do
                    print_colored "$RED" "Sending SIGKILL to process $pid..."
                    kill -9 "$pid" 2>/dev/null || true
                done
                
                # One final check
                sleep 1
                pids=($(pgrep -f "$process_name" || echo ""))
                if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
                    print_colored "$RED" "❌ WARNING: Failed to terminate some processes for $process_name!"
                    print_colored "$RED" "PIDs still running: ${pids[*]}"
                    print_colored "$YELLOW" "You may need to manually terminate these processes with 'sudo kill -9 ${pids[*]}'"
                    return 1
                fi
            fi
        fi
        
        # Check if any child processes with similar names remain
        local child_pids=($(ps aux | grep -i "[n]ock" | grep -i "$instance_id" | awk '{print $2}' || echo ""))
        if [ ${#child_pids[@]} -gt 0 ] && [ -n "${child_pids[0]}" ]; then
            print_colored "$YELLOW" "Found ${#child_pids[@]} related child processes. Terminating..."
            for pid in "${child_pids[@]}"; do
                print_colored "$CYAN" "Killing child process $pid..."
                kill -9 "$pid" 2>/dev/null || true
            done
        fi
        
        print_colored "$GREEN" "✅ Process cleanup for $process_name completed."
        
        # Check memory and clean up any leaked memory
        if command_exists sync; then
            sync
            if [[ "$(detect_os)" == "linux" ]] && [ -w /proc/sys/vm/drop_caches ]; then
                print_colored "$CYAN" "🧹 Cleaning up system memory cache..."
                sudo sh -c "echo 1 > /proc/sys/vm/drop_caches" 2>/dev/null || true
            fi
        fi
    fi
}

# Function to clean up all zombie nockchain processes
cleanup_all_zombies() {
    print_colored "$YELLOW" "🔍 Searching for all zombie nockchain processes..."
    
    # First look for numbered instances
    local instance_pids=($(ps aux | grep -i "[n]ock-[0-9]" | awk '{print $2}' || echo ""))
    
    # Check if any of these don't have associated screen sessions
    if [ ${#instance_pids[@]} -gt 0 ] && [ -n "${instance_pids[0]}" ]; then
        for pid in "${instance_pids[@]}"; do
            local process=$(ps -p "$pid" -o comm= | grep -o "nock-[0-9]\+" || echo "")
            
            if [ -n "$process" ] && ! screen -list | grep -q "$process"; then
                print_colored "$RED" "⚠️ Found zombie process: $process (PID: $pid) with no screen session"
                
                # Extract the instance id
                if [[ $process =~ nock-([0-9]+) ]]; then
                    local instance_id="${BASH_REMATCH[1]}"
                    kill_zombie_processes "$instance_id"
                else
                    # If we can't extract an ID, just kill the process directly
                    print_colored "$RED" "Killing process $pid directly..."
                    kill -9 "$pid" 2>/dev/null || true
                fi
            fi
        done
    fi
    
    # Look for main nockchain process without screen
    if pgrep -f "nockchain" > /dev/null && ! screen -list | grep -q "nock[[:space:]]"; then
        print_colored "$RED" "⚠️ Found main nockchain process with no screen session"
        
        local main_pids=($(pgrep -f "nockchain" | grep -v "nock-" || echo ""))
        if [ ${#main_pids[@]} -gt 0 ] && [ -n "${main_pids[0]}" ]; then
            print_colored "$YELLOW" "Terminating ${#main_pids[@]} main nockchain processes..."
            
            # Try graceful termination first
            for pid in "${main_pids[@]}"; do
                print_colored "$CYAN" "Sending SIGTERM to process $pid..."
                kill -15 "$pid" 2>/dev/null || true
            done
            
            sleep 2
            
            # If still running, force kill
            main_pids=($(pgrep -f "nockchain" | grep -v "nock-" || echo ""))
            if [ ${#main_pids[@]} -gt 0 ] && [ -n "${main_pids[0]}" ]; then
                for pid in "${main_pids[@]}"; do
                    print_colored "$RED" "Forcing termination of process $pid..."
                    kill -9 "$pid" 2>/dev/null || true
                done
            fi
        fi
    fi
    
    # Final check for any remaining nockchain processes
    if pgrep -f "nock" > /dev/null; then
        print_colored "$YELLOW" "Some nockchain processes may still be running."
        print_colored "$YELLOW" "Run 'ps aux | grep nock' to check, or 'pkill -9 -f nock' to force terminate all."
    else
        print_colored "$GREEN" "✅ All zombie nockchain processes have been terminated."
    fi
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to prompt for user confirmation
confirm() {
    print_colored "$YELLOW" "$1 [Y/n] "
    read -p "" response
    case "$response" in
        [nN][oO]|[nN]) 
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

# Function to check and install dependencies
check_dependencies() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                    CHECKING DEPENDENCIES                         ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    local os=$(detect_os)
    local missing_deps=()
    local deps=("curl" "git" "wget" "btop")
    
    # Check for missing dependencies
    for dep in "${deps[@]}"; do
        if ! command_exists "$dep"; then
            missing_deps+=("$dep")
        else
            print_colored "$GREEN" "✅ $dep is already installed."
        fi
    done
    
    # Check for screen on Linux and macOS
    if ! command_exists screen; then
        print_colored "$YELLOW" "screen is required but not installed."
        if confirm "Would you like to install screen?"; then
            if [[ "$os" == "macos" ]]; then
                print_colored "$CYAN" "Installing screen using Homebrew..."
                brew install screen
            elif [[ "$os" == "linux" ]]; then
                print_colored "$CYAN" "Installing screen using system package manager..."
                if command_exists apt-get; then
                    sudo apt-get update
                    sudo apt-get install -y screen
                elif command_exists yum; then
                    sudo yum install -y screen
                else
                    print_colored "$RED" "Cannot automatically install screen. Please install it manually and try again."
                    return 1
                fi
            fi
            print_colored "$GREEN" "✅ screen installed successfully."
        else
            print_colored "$YELLOW" "Screen installation skipped. Cannot run nockchain in background without screen."
            return 1
        fi
    else
        print_colored "$GREEN" "✅ screen is already installed."
    fi
    
    # If all dependencies are installed
    if [ ${#missing_deps[@]} -eq 0 ]; then
        print_colored "$GREEN" "All dependencies are installed."
        return 0
    fi
    
    # Ask user to install missing dependencies
    print_colored "$YELLOW" "The following dependencies are missing: ${missing_deps[*]}"
    if ! confirm "Would you like to install them?"; then
        print_colored "$YELLOW" "Dependencies installation skipped. Some features may not work properly."
        return 1
    fi
    
    # Install missing dependencies based on OS
    if [[ "$os" == "macos" ]]; then
        if ! command_exists brew; then
            print_colored "$YELLOW" "Homebrew is required but was not found."
            if confirm "Would you like to install Homebrew?"; then
                /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            else
                print_colored "$YELLOW" "Homebrew installation skipped. Cannot install dependencies without Homebrew."
                return 1
            fi
        fi
        
        for dep in "${missing_deps[@]}"; do
            print_colored "$CYAN" "Installing $dep using Homebrew..."
            brew install "$dep"
        done
    elif [[ "$os" == "linux" ]]; then
        if command_exists apt-get; then
            print_colored "$CYAN" "Installing dependencies using apt-get..."
            sudo apt-get update
            sudo apt-get install -y "${missing_deps[@]}"
        elif command_exists yum; then
            print_colored "$CYAN" "Installing dependencies using yum..."
            sudo yum install -y "${missing_deps[@]}"
        else
            print_colored "$RED" "Cannot automatically install dependencies. Please install them manually and try again."
            return 1
        fi
    fi
    
    # Verify installation
    local still_missing=()
    for dep in "${missing_deps[@]}"; do
        if ! command_exists "$dep"; then
            still_missing+=("$dep")
        else
            print_colored "$GREEN" "✅ $dep installed successfully."
        fi
    done
    
    if [ ${#still_missing[@]} -eq 0 ]; then
        print_colored "$GREEN" "All dependencies installed successfully."
        return 0
    else
        print_colored "$RED" "The following dependencies could not be installed: ${still_missing[*]}"
        print_colored "$YELLOW" "Please install them manually and try again."
        return 1
    fi
}

# Function to get the latest release tag from GitHub
get_latest_release_tag() {
    local repo="sarkrui/nockchain-auto"
    local tag=""
    
    if command_exists curl; then
        tag=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command_exists wget; then
        tag=$(wget -qO- "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    
    if [ -z "$tag" ]; then
        echo "unknown"
    else
        echo "$tag"
    fi
}

# Function to download/update release binaries
download_binaries() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                DOWNLOADING NOCKCHAIN BINARIES                   ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    # Check dependencies first
    check_dependencies
    
    local os=$(detect_os)
    local arch=$(detect_arch)
    local release_tag=$(get_latest_release_tag)
    
    echo "Detected: $os on $arch"
    echo "Latest release: $release_tag"
    
    # Create installation directory if it doesn't exist
    if [ ! -d "$INSTALL_DIR" ]; then
        echo "Creating installation directory: $INSTALL_DIR"
        mkdir -p "$INSTALL_DIR"
    fi
    
    # Set download URL based on OS and architecture
    local download_url="https://github.com/sarkrui/nockchain-auto/releases/latest/download/nockchain-all-$os-$arch.zip"
    local temp_zip="$INSTALL_DIR/nockchain-all-$os-$arch.zip"
    
    echo "Downloading nockchain binaries from: $download_url ($release_tag)"
    
    # Download the zip file
    if command_exists curl; then
        curl -L "$download_url" -o "$temp_zip"
    else
        wget "$download_url" -O "$temp_zip"
    fi
    
    if [ ! -f "$temp_zip" ]; then
        echo "Failed to download nockchain binaries"
        exit 1
    fi
    
    # Extract the zip file
    echo "Extracting binaries to $INSTALL_DIR"
    unzip -o "$temp_zip" -d "$INSTALL_DIR"
    
    # Make binaries executable
    echo "Making binaries executable"
    chmod +x "$INSTALL_DIR/nockchain-wallet" "$INSTALL_DIR/equix-latency" "$INSTALL_DIR/hoonc" "$INSTALL_DIR/nockchain" "$INSTALL_DIR/nockchain-bitcoin-sync"
    
    # Clean up
    echo "Cleaning up"
    rm "$temp_zip"
    
    echo "✅ Download complete!"
    echo "📂 Nockchain binaries have been downloaded to: $INSTALL_DIR"
}

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "Unsupported operating system: $OSTYPE"
        exit 1
    fi
}

# Detect architecture
detect_arch() {
    local arch=$(uname -m)
    if [[ "$arch" == "x86_64" ]]; then
        echo "x86_64"
    elif [[ "$arch" == "arm64" ]] || [[ "$arch" == "aarch64" ]]; then
        echo "arm64"
    else
        echo "Unsupported architecture: $arch"
        exit 1
    fi
}

# Detect preferred shell for screen
detect_shell() {
    local os=$(detect_os)
    if [[ "$os" == "macos" ]] && command_exists zsh; then
        echo "zsh"
    else
        echo "bash"
    fi
}

# Get miner status
get_miner_status() {
    if ! command_exists screen; then
        print_colored "$RED" "📛 Screen not installed"
        return
    fi
    
    # Check for single miner instance
    if screen -list | grep -q "nock$"; then
        print_colored "$GREEN" "✅ Default miner is RUNNING in screen session 'nock'"
    else
        print_colored "$RED" "❌ Default miner is NOT running"
    fi
    
    # Check for batch instances
    local batch_count=0
    local batch_list=""
    
    while read -r line; do
        if [[ $line =~ nock-([0-9]+) ]]; then
            batch_count=$((batch_count+1))
            batch_list="${batch_list}nock-${BASH_REMATCH[1]}, "
        fi
    done < <(screen -list | grep -o "nock-[0-9]\+")
    
    if [ $batch_count -gt 0 ]; then
        # Remove trailing comma and space
        batch_list=${batch_list%, }
        print_colored "$GREEN" "✅ $batch_count batch miner instances RUNNING: $batch_list"
    fi
    
    # Check for zombie processes (nock-N processes without matching screen sessions)
    local zombie_count=0
    local zombie_list=""
    
    for proc in $(pgrep -f "nock-[0-9]+" | sort); do
        local proc_name=$(ps -p "$proc" -o comm= | grep -o "nock-[0-9]\+")
        if [[ -n "$proc_name" ]] && ! screen -list | grep -q "$proc_name"; then
            zombie_count=$((zombie_count+1))
            zombie_list="${zombie_list}${proc_name}(PID:$proc), "
        fi
    done
    
    if [ $zombie_count -gt 0 ]; then
        # Remove trailing comma and space
        zombie_list=${zombie_list%, }
        print_colored "$RED" "⚠️ $zombie_count zombie miner processes detected: $zombie_list"
        print_colored "$YELLOW" "   Run 'nockhelper list' to manage these processes."
    fi
}

# Install the script globally
install_helper_globally() {
    local os=$(detect_os)
    local install_path=""
    
    # Determine installation path based on OS
    if [[ "$os" == "macos" ]]; then
        install_path="$SYS_BIN_DIR/nockhelper"
    else
        install_path="$SYS_BIN_DIR/nockhelper"
    fi
    
    # First try to download the latest helper script from remote
    if command_exists curl; then
        echo "Downloading latest helper script from remote..."
        if curl -s --head --fail "$HELPER_REMOTE" >/dev/null; then
            echo "Copying helper script to $install_path..."
            if [[ "$os" == "macos" ]]; then
                curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            if [ -f "$install_path" ]; then
                sudo chmod +x "$install_path"
                echo "✅ Helper script installed to $install_path."
            else
                echo "❌ Failed to install helper script to $install_path. Using local copy in $INSTALL_DIR."
                cp "$0" "$HELPER_SCRIPT"
                chmod +x "$HELPER_SCRIPT"
            fi
        else
            echo "ℹ️ Helper script not found at remote URL. Using local copy."
            cp "$0" "$HELPER_SCRIPT"
            chmod +x "$HELPER_SCRIPT"
            
            if [[ "$os" == "macos" ]]; then
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            sudo chmod +x "$install_path"
        fi
    elif command_exists wget; then
        echo "Downloading latest helper script from remote..."
        if wget --spider "$HELPER_REMOTE" 2>/dev/null; then
            echo "Copying helper script to $install_path..."
            if [[ "$os" == "macos" ]]; then
                wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            if [ -f "$install_path" ]; then
                sudo chmod +x "$install_path"
                echo "✅ Helper script installed to $install_path."
            else
                echo "❌ Failed to install helper script to $install_path. Using local copy in $INSTALL_DIR."
                cp "$0" "$HELPER_SCRIPT"
                chmod +x "$HELPER_SCRIPT"
            fi
        else
            echo "ℹ️ Helper script not found at remote URL. Using local copy."
            cp "$0" "$HELPER_SCRIPT"
            chmod +x "$HELPER_SCRIPT"
            
            if [[ "$os" == "macos" ]]; then
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            sudo chmod +x "$install_path"
        fi
    else
        echo "Neither curl nor wget found. Using local copy."
        cp "$0" "$HELPER_SCRIPT"
        chmod +x "$HELPER_SCRIPT"
        
        if [[ "$os" == "macos" ]]; then
            sudo cp "$HELPER_SCRIPT" "$install_path"
        else
            sudo cp "$HELPER_SCRIPT" "$install_path"
        fi
        sudo chmod +x "$install_path"
    fi
    
    echo "nockhelper installed globally at $install_path. Binaries will be in $INSTALL_DIR."
}

# Function to get the installed nockchain version
get_installed_nockchain_version() {
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        echo "not_installed"
        return
    fi
    
    # Try to get version from nockchain binary
    local version=$("$INSTALL_DIR/nockchain" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
    
    # If that fails, try to get a timestamp from the binary
    if [ -z "$version" ]; then
        local file_date=$(stat -c %y "$INSTALL_DIR/nockchain" 2>/dev/null || stat -f "%Sm" "$INSTALL_DIR/nockchain" 2>/dev/null)
        if [ -n "$file_date" ]; then
            echo "unknown (installed on $file_date)"
            return
        else
            echo "unknown"
            return
        fi
    fi
    
    echo "$version"
}

# Function to get the installed nockhelper version
get_installed_nockhelper_version() {
    # Return the version defined at the top of the script
    echo "$NOCKHELPER_VERSION"
}

# Function to get the latest nockhelper version from GitHub
get_latest_nockhelper_version() {
    local repo="sarkrui/nockchain-auto"
    local tag=""
    
    if command_exists curl; then
        tag=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command_exists wget; then
        tag=$(wget -qO- "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    
    if [ -z "$tag" ]; then
        echo "unknown"
    else
        echo "$tag"
    fi
}

# Function to compare versions
version_gt() {
    test "$(printf '%s\n' "$1" "$2" | sort -V | head -n 1)" != "$1"
}

# Function to check for nockchain updates
check_for_nockchain_updates() {
    local installed_version=$(get_installed_nockchain_version)
    local latest_version=$(get_latest_release_tag)
    
    if [ "$installed_version" = "not_installed" ]; then
        echo "ℹ️ Nockchain is not installed."
        return 1
    fi
    
    echo "Nockchain:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # If either version is unknown, we can't compare
    if [[ "$installed_version" == *"unknown"* ]] || [[ "$latest_version" == "unknown" ]]; then
        echo "ℹ️ Cannot determine if a nockchain update is needed."
        return 2
    fi
    
    # Remove 'v' prefix if present
    installed_version=${installed_version#v}
    latest_version=${latest_version#v}
    
    if version_gt "$latest_version" "$installed_version"; then
        echo "✅ Nockchain update available! Version $latest_version is newer than your installed version $installed_version."
        return 0
    else
        echo "✅ You have the latest nockchain version ($installed_version)."
        return 3
    fi
}

# Function to check for nockhelper updates
check_for_nockhelper_updates() {
    local installed_version=$(get_installed_nockhelper_version)
    local latest_version=$(get_latest_nockhelper_version)
    
    echo "Nockhelper:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # If either version is unknown, we can't compare
    if [[ "$installed_version" == *"unknown"* ]] || [[ "$latest_version" == "unknown" ]]; then
        echo "ℹ️ Cannot determine if a nockhelper update is needed."
        return 2
    fi
    
    # Remove 'v' prefix if present
    installed_version=${installed_version#v}
    latest_version=${latest_version#v}
    
    if version_gt "$latest_version" "$installed_version"; then
        echo "✅ Nockhelper update available! Version $latest_version is newer than your installed version $installed_version."
        return 0
    else
        echo "✅ You have the latest nockhelper version ($installed_version)."
        return 3
    fi
}

# Function to check for all updates
check_for_updates() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                     CHECKING FOR UPDATES                        ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    check_for_nockchain_updates
    echo ""
    check_for_nockhelper_updates
    
    return 0
}

# Function to delete nockchain instance directories
delete_nockchain_instances() {
    local instance_id=$1
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                 DELETING NOCKCHAIN INSTANCES                    ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    if [ "$instance_id" = "all" ]; then
        print_colored "$YELLOW" "Deleting all nockchain instance directories..."
        
        # Check if any instance directories exist
        local count=0
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ]; then
                count=$((count+1))
            fi
        done
        
        if [ $count -eq 0 ]; then
            print_colored "$RED" "❌ No nockchain instance directories found."
            return 1
        fi
        
        # Confirm deletion of all instances
        if ! confirm "Are you sure you want to delete all $count nockchain instance directories?"; then
            print_colored "$BLUE" "Deletion cancelled."
            return 0
        fi
        
        # Stop all running instances first
        if command_exists screen; then
            while read -r line; do
                if [[ $line =~ nock-([0-9]+) ]]; then
                    local session="nock-${BASH_REMATCH[1]}"
                    local instance_num="${BASH_REMATCH[1]}"
                    print_colored "$YELLOW" "Stopping screen session $session..."
                    # First try to gracefully terminate the nockchain process
                    screen -S "$session" -X stuff $'\003'  # Send Ctrl+C
                    sleep 1
                    # Then quit the screen session
                    screen -S "$session" -X quit 2>/dev/null || true
                    
                    # Kill any zombie processes
                    kill_zombie_processes "$instance_num"
                fi
            done < <(screen -list | grep -o "nock-[0-9]\+")
        fi
        
        # Delete all instance directories
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ]; then
                print_colored "$YELLOW" "Removing $dir..."
                rm -rf "$dir"
            fi
        done
        
        print_colored "$GREEN" "✅ All nockchain instance directories have been deleted."
    else
        # Check if instance_id includes "nock-" prefix
        local screen_name=""
        local instance_dir=""
        local instance_num=""
        
        if [[ "$instance_id" == nock-* ]]; then
            # Format is nock-N
            screen_name="$instance_id"
            instance_num="${BASH_REMATCH[1]}"
            instance_dir="$INSTALL_DIR/$instance_id"
        elif [[ "$instance_id" =~ ^[0-9]+$ ]]; then
            # Format is just N
            instance_num="$instance_id"
            screen_name="nock-$instance_id"
            instance_dir="$INSTALL_DIR/$screen_name"
        else
            print_colored "$RED" "❌ Invalid instance ID format. Use 'nock-N', 'N', or 'all'."
            return 1
        fi
        
        if [ ! -d "$instance_dir" ]; then
            print_colored "$RED" "❌ Nockchain instance directory not found: $instance_dir"
            return 1
        fi
        
        # Confirm deletion of specific instance
        if ! confirm "Are you sure you want to delete nockchain instance $screen_name?"; then
            print_colored "$BLUE" "Deletion cancelled."
            return 0
        fi
        
        # Stop the running instance first
        if command_exists screen; then
            if screen -list | grep -q "$screen_name"; then
                print_colored "$YELLOW" "Stopping screen session $screen_name..."
                
                # First try to gracefully terminate the nockchain process with Ctrl+C
                print_colored "$YELLOW" "Sending termination signal to nockchain process..."
                screen -S "$screen_name" -X stuff $'\003'  # Send Ctrl+C
                
                # Give it a moment to shut down
                sleep 2
                
                # Now quit the screen session
                print_colored "$YELLOW" "Terminating screen session..."
                screen -S "$screen_name" -X quit 2>/dev/null || true
                
                # Kill any zombie processes
                kill_zombie_processes "$instance_num"
                
                # Wait a bit to ensure the screen session is fully terminated
                sleep 1
            else
                print_colored "$YELLOW" "No running screen session found for $screen_name."
            fi
        fi
        
        # Delete instance directory
        print_colored "$YELLOW" "Removing $instance_dir..."
        rm -rf "$instance_dir"
        
        print_colored "$GREEN" "✅ Nockchain instance $screen_name has been deleted."
    fi
    
    return 0
}

# List and manage screen sessions
list_screen_sessions() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                  NOCKCHAIN SCREEN SESSIONS                      ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    if ! command_exists screen; then
        print_colored "$RED" "❌ screen is not installed."
        return 1
    fi
    
    # Get all nockchain-related screen sessions
    local sessions=()
    local i=0
    
    # Check for default nock session
    if screen -list | grep -q "nock[[:space:]]"; then
        sessions[$i]="nock"
        i=$((i+1))
    fi
    
    # Check for batch instances
    while read -r line; do
        if [[ $line =~ nock-([0-9]+) ]]; then
            sessions[$i]="${BASH_REMATCH[0]}"
            i=$((i+1))
        fi
    done < <(screen -list | grep -o "nock-[0-9]\+")
    
    # Display sessions
    if [ ${#sessions[@]} -eq 0 ]; then
        print_colored "$YELLOW" "No nockchain screen sessions found."
        return 0
    fi
    
    print_colored "$GREEN" "Found ${#sessions[@]} nockchain screen sessions:"
    echo ""
    
    for ((i=0; i<${#sessions[@]}; i++)); do
        print_colored "$CYAN" "  [${BOLD}$((i+1))${NC}${CYAN}] ${sessions[$i]}"
    done
    
    echo ""
    print_colored "$MAGENTA" "What would you like to do?"
    print_colored "$CYAN" "  [${BOLD}a${NC}${CYAN}] Attach to a session"
    print_colored "$CYAN" "  [${BOLD}k${NC}${CYAN}] Kill (stop) a session"
    print_colored "$CYAN" "  [${BOLD}v${NC}${CYAN}] View session logs"
    print_colored "$CYAN" "  [${BOLD}q${NC}${CYAN}] Quit this menu"
    
    read -p "Enter your choice [a/k/v/q]: " choice
    
    case "$choice" in
        a|A)
            read -p "Enter session number to attach to: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$GREEN" "Attaching to session ${sessions[$((session_num-1))]}..."
                exec screen -r "${sessions[$((session_num-1))]}"
            else
                print_colored "$RED" "❌ Invalid session number."
            fi
            ;;
        k|K)
            read -p "Enter session number to kill: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$YELLOW" "Killing session ${sessions[$((session_num-1))]}..."
                # First try to gracefully terminate the nockchain process
                screen -S "${sessions[$((session_num-1))]}" -X stuff $'\003'  # Send Ctrl+C
                sleep 1
                # Then quit the screen session
                screen -S "${sessions[$((session_num-1))]}" -X quit 2>/dev/null || true
                
                # Check if it's a batch instance and kill any zombie processes
                if [[ "${sessions[$((session_num-1))]}" =~ nock-([0-9]+) ]]; then
                    local instance_id="${BASH_REMATCH[1]}"
                    kill_zombie_processes "$instance_id"
                fi
                
                print_colored "$GREEN" "✅ Session terminated."
            else
                print_colored "$RED" "❌ Invalid session number."
            fi
            ;;
        v|V)
            read -p "Enter session number to view logs: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$GREEN" "Viewing logs for session ${sessions[$((session_num-1))]}..."
                screen -S "${sessions[$((session_num-1))]}" -X hardcopy "/tmp/nockchain_screen_log"
                if [ -f "/tmp/nockchain_screen_log" ]; then
                    less "/tmp/nockchain_screen_log"
                    rm "/tmp/nockchain_screen_log"
                else
                    print_colored "$RED" "❌ Failed to capture logs."
                fi
            else
                print_colored "$RED" "❌ Invalid session number."
            fi
            ;;
        q|Q)
            print_colored "$BLUE" "Exiting menu."
            ;;
        *)
            print_colored "$RED" "❌ Invalid choice."
            ;;
    esac
    
    return 0
}

# Display help message
display_help() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                      NOCKCHAIN HELPER TOOL                      ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    echo ""
    print_colored "$MAGENTA" "CURRENT STATUS:"
    print_colored "$MAGENTA" "⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯"
    print_colored "$CYAN" "📂 Install Location: $INSTALL_DIR"
    print_colored "$CYAN" "🛠️ Nockhelper: $(get_installed_nockhelper_version)"
    
    # Skip update check when displaying help to avoid GitHub API rate limits
    print_colored "$CYAN" "🔄 Nockhelper Update Status: Use 'nockhelper check' to check for updates"
    
    if [ -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$GREEN" "📦 Nockchain: Installed ($(get_installed_nockchain_version))"
        print_colored "$CYAN" "🔄 Nockchain Update Status: Use 'nockhelper check' to check for updates"
    else
        print_colored "$RED" "📦 Nockchain: Not installed"
    fi
    get_miner_status
    echo ""
    echo ""
    
    print_colored "$MAGENTA" "COMMANDS:"
    print_colored "$MAGENTA" "⎯⎯⎯⎯⎯⎯⎯⎯⎯"
    print_colored "$YELLOW" "  ${BOLD}install${NC}    - Install nockchain binaries"
    print_colored "$CYAN" "               Usage: nockhelper install"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update${NC}     - Update nockchain binaries and helper script"
    print_colored "$CYAN" "               Usage: nockhelper update"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update-nockchain${NC} - Update nockchain binaries"
    print_colored "$CYAN" "               Usage: nockhelper update-nockchain"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update-nockhelper${NC} - Update nockhelper script"
    print_colored "$CYAN" "               Usage: nockhelper update-nockhelper"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}download${NC}   - Download/update nockchain binaries from latest release"
    print_colored "$CYAN" "               Usage: nockhelper download"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}check${NC}      - Check for nockchain updates"
    print_colored "$CYAN" "               Usage: nockhelper check"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}run${NC}        - Run nockchain miner in a screen session"
    print_colored "$CYAN" "               Usage: nockhelper run"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}run <N>${NC}    - Run N instances of nockchain miners in separate screen sessions"
    print_colored "$CYAN" "               Usage: nockhelper run 10"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}list${NC}       - List and manage nockchain screen sessions"
    print_colored "$CYAN" "               Usage: nockhelper list"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}cleanup${NC}    - Clean up all zombie nockchain processes"
    print_colored "$CYAN" "               Usage: nockhelper cleanup"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}del <id>${NC}   - Delete a specific nockchain instance directory"
    print_colored "$CYAN" "               Usage: nockhelper del 1"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}del all${NC}    - Delete all nockchain instance directories"
    print_colored "$CYAN" "               Usage: nockhelper del all"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}uninstall${NC}  - Remove nockchain installation"
    print_colored "$CYAN" "               Usage: nockhelper uninstall"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}status${NC}     - Check miner status"
    print_colored "$CYAN" "               Usage: nockhelper status"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}help${NC}       - Display this help message"
    print_colored "$CYAN" "               Usage: nockhelper help"
    echo ""
    
    print_colored "$MAGENTA" "SCREEN MANAGEMENT:"
    print_colored "$MAGENTA" "⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯"
    print_colored "$CYAN" "  To attach to running miner:  ${BOLD}screen -r nock${NC}"
    print_colored "$CYAN" "  To detach from session:      Press ${BOLD}Ctrl+A${NC}, then ${BOLD}D${NC}"
    print_colored "$CYAN" "  To stop the miner:           ${BOLD}screen -S nock -X quit${NC}"
    echo ""
    
    print_colored "$MAGENTA" "ENVIRONMENT:"
    print_colored "$MAGENTA" "⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯"
    print_colored "$CYAN" "  Operating System: $(detect_os)"
    print_colored "$CYAN" "  Architecture:     $(detect_arch)"
    print_colored "$CYAN" "  Preferred Shell:  $(detect_shell)"
    echo ""
    
    print_colored "$GREEN" "For more information, visit: https://github.com/sarkrui/nockchain-auto"
}

# Check status
check_status() {
    # Check dependencies first
    check_dependencies
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                        NOCKCHAIN STATUS                         ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    print_colored "$CYAN" "🛠️ Nockhelper version: $(get_installed_nockhelper_version)"
    
    if [ -d "$INSTALL_DIR" ]; then
        print_colored "$GREEN" "📂 Installation directory: $INSTALL_DIR (exists)"
    else
        print_colored "$RED" "📂 Installation directory: $INSTALL_DIR (missing)"
    fi
    
    if [ -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$GREEN" "📦 Nockchain binary: Found and executable"
        print_colored "$CYAN" "📦 Nockchain version: $(get_installed_nockchain_version)"
        check_for_nockchain_updates
    else
        print_colored "$RED" "📦 Nockchain binary: Not found or not executable"
    fi
    
    get_miner_status
    
    # Check for zombie processes not associated with any screen session
    local zombie_procs=$(pgrep -f "nock-[0-9]+" | wc -l)
    local screen_sessions=$(screen -list 2>/dev/null | grep -c "nock-[0-9]\+")
    
    # If there are more processes than screen sessions, we have zombies
    if [ "$zombie_procs" -gt "$screen_sessions" ] && [ "$zombie_procs" -gt 0 ]; then
        print_colored "$RED" "⚠️ Detected potential zombie nockchain processes!"
        print_colored "$YELLOW" "   Run 'ps aux | grep nock-' to see them"
        print_colored "$YELLOW" "   Use 'nockhelper cleanup' to terminate all zombie processes"
    fi
    
    # Check for batch miner instances directories
    if [ -d "$INSTALL_DIR" ]; then
        local batch_dirs=0
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ] && [ -x "$dir/nock-"* ]; then
                batch_dirs=$((batch_dirs+1))
            fi
        done
        
        if [ $batch_dirs -gt 0 ]; then
            print_colored "$CYAN" "📦 Batch miner instance directories found: $batch_dirs"
        fi
    fi
    
    if command_exists screen; then
        # Commands for single instance
        if screen -list | grep -q "nock$"; then
            echo ""
            print_colored "$MAGENTA" "Default Miner Control Commands:"
            print_colored "$CYAN" "  Attach to miner: ${BOLD}screen -r nock${NC}"
            print_colored "$CYAN" "  Stop miner:      ${BOLD}screen -S nock -X quit${NC}"
        fi
        
        # Commands for batch instances
        local batch_running=0
        while read -r line; do
            if [[ $line =~ nock-([0-9]+) ]]; then
                batch_running=$((batch_running+1))
            fi
        done < <(screen -list | grep -o "nock-[0-9]\+")
        
        if [ $batch_running -gt 0 ]; then
            echo ""
            print_colored "$MAGENTA" "Batch Miners Control Commands:"
            print_colored "$CYAN" "  List all sessions:      ${BOLD}screen -ls${NC}"
            print_colored "$CYAN" "  Attach to miner #N:     ${BOLD}screen -r nock-N${NC}"
            print_colored "$CYAN" "  Stop miner #N:          ${BOLD}screen -S nock-N -X quit${NC}"
            print_colored "$CYAN" "  Stop all batch miners:  ${BOLD}for i in \$(screen -ls | grep nock- | awk '{print \$1}'); do screen -S \$i -X quit; done${NC}"
        fi
    fi
}

# Install nockchain
install_nockchain() {
    # Check dependencies first
    check_dependencies
    
    local os=$(detect_os)
    local arch=$(detect_arch)
    local release_tag=$(get_latest_release_tag)
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                   NOCKCHAIN INSTALLATION WIZARD                 ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    echo "Detected: $os on $arch"
    echo "Latest release: $release_tag"

    # Install screen using Homebrew on macOS
    if [[ "$os" == "macos" ]]; then
        if ! command_exists brew; then
            echo "Homebrew is required but was not found."
            if confirm "Would you like to install Homebrew?"; then
                /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            else
                echo "Homebrew installation skipped. Cannot continue without Homebrew."
                exit 1
            fi
        fi
        
        if ! command_exists screen; then
            if confirm "Screen is required but not installed. Would you like to install screen?"; then
                echo "Installing screen using Homebrew..."
                brew install screen
            else
                echo "Screen installation skipped. Cannot run nockchain in background without screen."
            fi
        else
            echo "✅ screen is already installed."
        fi
    fi

    # Check if download tools are available
    if ! command_exists curl && ! command_exists wget; then
        echo "Either curl or wget is required but neither was found. Please install one of them and try again."
        exit 1
    fi

    # Check if unzip is installed
    if ! command_exists unzip; then
        echo "unzip is required but was not found."
        if confirm "Would you like to install unzip?"; then
            if [[ "$os" == "macos" ]]; then
                brew install unzip
            elif [[ "$os" == "linux" ]]; then
                if command_exists apt-get; then
                    sudo apt-get install -y unzip
                elif command_exists yum; then
                    sudo yum install -y unzip
                else
                    echo "Cannot automatically install unzip. Please install it manually and try again."
                    exit 1
                fi
            fi
        else
            echo "Unzip installation skipped. Cannot continue without unzip."
            exit 1
        fi
    fi

    # Confirm installation
    if ! confirm "Ready to install nockchain to $INSTALL_DIR. Continue?"; then
        echo "Installation aborted by user."
        exit 0
    fi

    # Create installation directory if it doesn't exist
    if [ ! -d "$INSTALL_DIR" ]; then
        echo "Creating installation directory: $INSTALL_DIR"
        mkdir -p "$INSTALL_DIR"
    fi

    # Set download URL based on OS and architecture
    local download_url="https://github.com/sarkrui/nockchain-auto/releases/latest/download/nockchain-all-$os-$arch.zip"
    local temp_zip="$INSTALL_DIR/nockchain-all-$os-$arch.zip"

    echo "Downloading nockchain binaries from: $download_url ($release_tag)"
    
    # Download the zip file
    if command_exists curl; then
        curl -L "$download_url" -o "$temp_zip"
    else
        wget "$download_url" -O "$temp_zip"
    fi

    if [ ! -f "$temp_zip" ]; then
        echo "Failed to download nockchain binaries"
        exit 1
    fi

    # Extract the zip file
    echo "Extracting binaries to $INSTALL_DIR"
    unzip -o "$temp_zip" -d "$INSTALL_DIR"

    # Make binaries executable
    echo "Making binaries executable"
    chmod +x "$INSTALL_DIR/nockchain-wallet" "$INSTALL_DIR/equix-latency" "$INSTALL_DIR/hoonc" "$INSTALL_DIR/nockchain" "$INSTALL_DIR/nockchain-bitcoin-sync"

    # Clean up
    echo "Cleaning up"
    rm "$temp_zip"
    
    # Install helper script globally
    install_helper_globally

    echo "✅ Installation complete!"
    echo "📂 Nockchain binaries have been installed to: $INSTALL_DIR"
    echo ""
    echo "💡 Next steps:"
    echo "   - Start mining: nockhelper run"
    echo "   - View help: nockhelper help"
}

# Update nockchain
update_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                     UPDATING NOCKCHAIN                          ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    local installed_version=$(get_installed_nockchain_version)
    local latest_version=$(get_latest_release_tag)
    
    echo "Nockchain:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # Check if update is needed
    if [[ "$installed_version" != "not_installed" ]] && [[ "$installed_version" != *"unknown"* ]] && [[ "$latest_version" != "unknown" ]]; then
        # Remove 'v' prefix if present
        installed_version=${installed_version#v}
        latest_version=${latest_version#v}
        
        if ! version_gt "$latest_version" "$installed_version"; then
            echo "ℹ️ You already have the latest nockchain version ($installed_version)."
            if ! confirm "Do you want to continue with the nockchain update anyway?"; then
                echo "Nockchain update cancelled."
                update_nockhelper
                return
            fi
        fi
    fi
    
    # Update binaries
    install_nockchain
    
    echo "✅ Nockchain update complete!"
}

# Update nockhelper
update_nockhelper() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                     UPDATING NOCKHELPER                         ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    local installed_version=$(get_installed_nockhelper_version)
    local latest_version=$(get_latest_nockhelper_version)
    
    echo "Nockhelper:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # Check if update is needed
    if [[ "$latest_version" != "unknown" ]]; then
        # Remove 'v' prefix if present
        installed_version=${installed_version#v}
        latest_version=${latest_version#v}
        
        if ! version_gt "$latest_version" "$installed_version"; then
            echo "ℹ️ You already have the latest nockhelper version ($installed_version)."
            if ! confirm "Do you want to continue with the nockhelper update anyway?"; then
                echo "Nockhelper update cancelled."
                return
            fi
        fi
    fi
    
    # Try to download the latest helper script
    if command_exists curl; then
        if curl -s --head --fail "$HELPER_REMOTE" >/dev/null; then
            echo "Updating helper script..."
            curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT.new"
            if [ -f "$HELPER_SCRIPT.new" ]; then
                chmod +x "$HELPER_SCRIPT.new"
                mv "$HELPER_SCRIPT.new" "$HELPER_SCRIPT"
                echo "✅ Helper script updated."
                # Execute the updated script for the rest of the update
                exec "$HELPER_SCRIPT" update
                exit 0
            else
                echo "❌ Failed to download updated helper script."
            fi
        else
            echo "ℹ️ Helper script not found at remote URL."
        fi
    elif command_exists wget; then
        if wget --spider "$HELPER_REMOTE" 2>/dev/null; then
            echo "Updating helper script..."
            wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT.new"
            if [ -f "$HELPER_SCRIPT.new" ]; then
                chmod +x "$HELPER_SCRIPT.new"
                mv "$HELPER_SCRIPT.new" "$HELPER_SCRIPT"
                echo "✅ Helper script updated."
                # Execute the updated script for the rest of the update
                exec "$HELPER_SCRIPT" update
                exit 0
            else
                echo "❌ Failed to download updated helper script."
            fi
        else
            echo "ℹ️ Helper script not found at remote URL."
        fi
    else
        echo "❌ Neither curl nor wget found. Cannot update helper script."
    fi
    
    echo "✅ Nockhelper update complete!"
}

# Update both nockchain and nockhelper
update_all() {
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                     UPDATING ALL COMPONENTS                     ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    update_nockhelper
    echo ""
    update_nockchain
    
    echo "✅ All updates complete!"
}

# Uninstall nockchain
uninstall_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                    UNINSTALLING NOCKCHAIN                       ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    if ! confirm "Are you sure you want to uninstall nockchain from $INSTALL_DIR?"; then
        echo "Uninstall cancelled."
        return
    fi
    
    echo "Uninstalling nockchain..."
    
    # Stop any running nockchain screen sessions
    if command_exists screen; then
        if screen -list | grep -q "nock"; then
            echo "Stopping nockchain screen sessions..."
            screen -S nock -X quit 2>/dev/null || true
        fi
    fi
    
    # Remove installation directory
    if [ -d "$INSTALL_DIR" ]; then
        echo "Removing installation directory: $INSTALL_DIR"
        rm -rf "$INSTALL_DIR"
    fi
    
    # Remove from PATH in shell config
    local os=$(detect_os)
    if [[ "$os" == "macos" ]]; then
        local shell_rc="$HOME/.zshrc"
        if [ -f "$shell_rc" ]; then
            echo "Removing from $shell_rc..."
            sed -i'.bak' '/# Added by nockhelper installer/d' "$shell_rc"
            sed -i'.bak' '/export PATH="\$PATH:\/Users\/.*\/nockbin"/d' "$shell_rc"
            rm -f "$shell_rc.bak"
        fi
    else
        local shell_rc="$HOME/.bashrc"
        if [ -f "$shell_rc" ]; then
            echo "Removing from $shell_rc..."
            sed -i '/# Added by nockhelper installer/d' "$shell_rc"
            sed -i '/export PATH="\$PATH:\/home\/.*\/nockbin"/d' "$shell_rc"
        fi
    fi
    
    echo "✅ Uninstall complete! Please restart your terminal or source your shell config."
}

# Run nockchain miner in screen
run_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║                    STARTING NOCKCHAIN MINER                     ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    if ! command_exists screen; then
        print_colored "$RED" "❌ screen is not installed. Cannot run nockchain in the background."
        return 1
    fi
    
    # Check if there's already a nockchain screen session
    if screen -list | grep -q "nock"; then
        print_colored "$YELLOW" "ℹ️ nockchain is already running in a screen session."
        print_colored "$CYAN" "   To attach to it, run: screen -r nock"
        print_colored "$CYAN" "   To kill it, run: screen -S nock -X quit"
        return 0
    fi
    
    # Make sure nockchain is installed
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$RED" "❌ nockchain binary not found or not executable."
        print_colored "$YELLOW" "   Please run 'nockhelper install' first."
        return 1
    fi
    
    print_colored "$CYAN" "Starting nockchain miner in a screen session..."
    
    # Detect preferred shell
    local shell=$(detect_shell)
    
    # For Linux, set vm.overcommit_memory=1
    local os=$(detect_os)
    if [[ "$os" == "linux" ]]; then
        print_colored "$YELLOW" "Setting vm.overcommit_memory=1 for Linux..."
        sudo sysctl -w vm.overcommit_memory=1
    fi
    
    # Create a wrapper script to handle cleanup when the screen session ends
    local wrapper_script="$INSTALL_DIR/start_nockchain.sh"
    
    cat > "$wrapper_script" << EOF
#!/bin/bash
# Wrapper script for main nockchain instance

# Store process IDs
export MAIN_PID=\$$
echo "\$MAIN_PID" > "$INSTALL_DIR/.nockchain_main_pid"

# Function to clean up when the script exits
cleanup() {
    echo "Cleaning up nockchain process..."
    
    # Get all child processes
    local children=\$(pgrep -P \$MAIN_PID 2>/dev/null || echo "")
    local grandchildren=""
    
    # For each child, get its children too
    for child in \$children; do
        local child_procs=\$(pgrep -P \$child 2>/dev/null || echo "")
        if [ -n "\$child_procs" ]; then
            grandchildren="\$grandchildren \$child_procs"
        fi
    done
    
    # Combine all processes
    local all_procs="\$children \$grandchildren"
    
    # Try graceful termination first
    if [ -n "\$all_procs" ]; then
        echo "Sending SIGTERM to child processes: \$all_procs"
        kill -15 \$all_procs 2>/dev/null || true
        sleep 2
        
        # Check if any processes still running
        local still_running=""
        for pid in \$all_procs; do
            if kill -0 \$pid 2>/dev/null; then
                still_running="\$still_running \$pid"
            fi
        done
        
        # If still running, force kill
        if [ -n "\$still_running" ]; then
            echo "Forcing termination of processes: \$still_running"
            kill -9 \$still_running 2>/dev/null || true
        fi
    fi
    
    # Also look for any remaining nockchain process directly
    local nock_procs=\$(pgrep -f "nockchain" | grep -v "\$MAIN_PID" || echo "")
    if [ -n "\$nock_procs" ]; then
        echo "Terminating nockchain processes: \$nock_procs"
        kill -15 \$nock_procs 2>/dev/null || true
        sleep 1
        kill -9 \$nock_procs 2>/dev/null || true
    fi
    
    # Clean up PID file
    rm -f "$INSTALL_DIR/.nockchain_main_pid"
    
    echo "Cleanup completed."
}

# Cleanup when any signal is received
trap cleanup EXIT SIGINT SIGTERM

# Change to installation directory
cd $INSTALL_DIR

# Clean up any previous data
rm -rf ./.data.nockchain .socket/nockchain_npc.sock

# Start the nockchain process
exec ./nockchain --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.108.123.225/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --peer /ip4/34.95.155.151/udp/30000/quic-v1 --peer /ip4/34.18.98.38/udp/30000/quic-v1
EOF

    chmod +x "$wrapper_script"
    
    # Create the screen session with the wrapper script
    screen -dmS nock $shell -c "$wrapper_script; exec $shell"
    
    print_colored "$GREEN" "✅ Nockchain miner is now running in a screen session named 'nock'"
    echo ""
    print_colored "$CYAN" "💡 SCREEN SESSION COMMANDS:"
    print_colored "$CYAN" "   To attach to the session:  screen -r nock"
    print_colored "$CYAN" "   To detach from the session:      Press Ctrl+A, then D"
    print_colored "$CYAN" "   To stop the miner:         screen -S nock -X quit"
    
    return 0
}

# Run multiple nockchain miners in separate screen sessions
run_batch_nockchain() {
    # Check dependencies first
    check_dependencies
    
    local num_instances=$1
    
    echo "╔═════════════════════════════════════════════════════════════════╗"
    echo "║               STARTING MULTIPLE NOCKCHAIN MINERS                ║"
    echo "╚═════════════════════════════════════════════════════════════════╝"
    
    if ! command_exists screen; then
        print_colored "$RED" "❌ screen is not installed. Cannot run nockchain in the background."
        return 1
    fi
    
    # Make sure nockchain is installed
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$RED" "❌ nockchain binary not found or not executable."
        print_colored "$YELLOW" "   Please run 'nockhelper install' first."
        return 1
    fi
    
    print_colored "$CYAN" "Starting $num_instances nockchain miner instances in separate screen sessions..."
    
    # Detect preferred shell
    local shell=$(detect_shell)
    
    # Environment variables for nockchain
    local env_vars="export RUST_LOG=\"info,nockchain=debug,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info\" && export MINIMAL_LOG_FORMAT=\"true\""
    
    # For Linux, set vm.overcommit_memory=1
    local os=$(detect_os)
    if [[ "$os" == "linux" ]]; then
        print_colored "$YELLOW" "Setting vm.overcommit_memory=1 for Linux..."
        sudo sysctl -w vm.overcommit_memory=1
    fi
    
    # Create directories and start instances
    for ((i=1; i<=$num_instances; i++)); do
        local instance_dir="$INSTALL_DIR/nock-$i"
        local screen_name="nock-$i"
        local binary_name="nock-$i"
        
        # Check if screen session already exists
        if screen -list | grep -q "$screen_name"; then
            print_colored "$YELLOW" "ℹ️ nockchain instance $i is already running in screen session '$screen_name'"
            continue
        fi
        
        # Create instance directory if it doesn't exist
        if [ ! -d "$instance_dir" ]; then
            print_colored "$BLUE" "Creating directory for instance $i: $instance_dir"
            mkdir -p "$instance_dir"
        fi
        
        # Copy nockchain binary to instance directory and rename it
        print_colored "$BLUE" "Copying and renaming nockchain binary to $binary_name for instance $i..."
        cp "$INSTALL_DIR/nockchain" "$instance_dir/$binary_name"
        chmod +x "$instance_dir/$binary_name"
        
        # Create screen session for this instance with trap to ensure process cleanup
        print_colored "$GREEN" "Starting nockchain instance $i in screen session '$screen_name'..."
        
        # Create a wrapper script to handle cleanup when the screen session ends
        cat > "$instance_dir/start_nockchain.sh" << EOF
#!/bin/bash
# Wrapper script for nockchain instance $i

# Store process IDs
export MAIN_PID=\$$
echo "\$MAIN_PID" > "$instance_dir/.nock_${i}_pid"

# Function to clean up when the script exits
cleanup() {
    echo "Cleaning up nockchain instance $i..."
    
    # Get all child processes
    local children=\$(pgrep -P \$MAIN_PID 2>/dev/null || echo "")
    local grandchildren=""
    
    # For each child, get its children too
    for child in \$children; do
        local child_procs=\$(pgrep -P \$child 2>/dev/null || echo "")
        if [ -n "\$child_procs" ]; then
            grandchildren="\$grandchildren \$child_procs"
        fi
    done
    
    # Combine all processes
    local all_procs="\$children \$grandchildren"
    
    # Try graceful termination first
    if [ -n "\$all_procs" ]; then
        echo "Sending SIGTERM to child processes: \$all_procs"
        kill -15 \$all_procs 2>/dev/null || true
        sleep 2
        
        # Check if any processes still running
        local still_running=""
        for pid in \$all_procs; do
            if kill -0 \$pid 2>/dev/null; then
                still_running="\$still_running \$pid"
            fi
        done
        
        # If still running, force kill
        if [ -n "\$still_running" ]; then
            echo "Forcing termination of processes: \$still_running"
            kill -9 \$still_running 2>/dev/null || true
        fi
    fi
    
    # Also look for any processes with our specific binary name
    local binary_procs=\$(pgrep -f "$binary_name" || echo "")
    if [ -n "\$binary_procs" ]; then
        echo "Terminating $binary_name processes: \$binary_procs"
        kill -15 \$binary_procs 2>/dev/null || true
        sleep 1
        kill -9 \$binary_procs 2>/dev/null || true
    fi
    
    # Clean up PID file
    rm -f "$instance_dir/.nock_${i}_pid"
    
    echo "Cleanup completed."
}

# Cleanup when any signal is received
trap cleanup EXIT SIGINT SIGTERM

# Set environment variables
$env_vars

# Change to instance directory
cd "$instance_dir" 

# Clean up any previous data
rm -rf ./.data.nockchain .socket/nockchain_npc.sock

# Start the nockchain process
exec ./$binary_name --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.108.123.225/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --peer /ip4/34.95.155.151/udp/30000/quic-v1 --peer /ip4/34.18.98.38/udp/30000/quic-v1 --peer /ip4/96.230.252.205/udp/3006/quic-v1 --peer /ip4/94.205.40.29/udp/3006/quic-v1 --peer /ip4/159.112.204.186/udp/3006/quic-v1 --peer /ip4/217.14.223.78/udp/3006/quic-v1
EOF

        chmod +x "$instance_dir/start_nockchain.sh"
        
        # Start the screen session with the wrapper script
        screen -dmS "$screen_name" $shell -c "$instance_dir/start_nockchain.sh; exec $shell"
        
        print_colored "$GREEN" "✅ Started nockchain instance $i in screen session '$screen_name'"
    done
    
    echo ""
    print_colored "$GREEN" "✅ All nockchain instances are now running"
    echo ""
    print_colored "$CYAN" "💡 SCREEN SESSION COMMANDS:"
    print_colored "$CYAN" "   To list all sessions:       screen -ls"
    print_colored "$CYAN" "   To attach to a session:     screen -r nock-<id>"
    print_colored "$CYAN" "   To detach from a session:   Press Ctrl+A, then D"
    print_colored "$CYAN" "   To stop a miner instance:   screen -S nock-<id> -X quit"
    
    return 0
}

# Main function
main() {
    # If script is called directly from installation
    if [ "$(basename "$0")" != "nockhelper" ]; then
        install_nockchain
        return
    fi

    # Parse command line arguments
    local command=${1:-""}
    local arg2=${2:-""}
    
    case "$command" in
        install)
            install_nockchain
            ;;
        update)
            update_all
            ;;
        update-nockchain)
            update_nockchain
            ;;
        update-nockhelper)
            update_nockhelper
            ;;
        download)
            download_binaries
            ;;
        check)
            check_for_updates
            ;;
        uninstall)
            uninstall_nockchain
            ;;
        run)
            if [[ "$arg2" =~ ^[0-9]+$ ]]; then
                # If run is followed by a number, run batch instances
                run_batch_nockchain "$arg2"
            else
                # Otherwise, run a single instance
                run_nockchain
            fi
            ;;
        list)
            list_screen_sessions
            ;;
        cleanup)
            echo "╔═════════════════════════════════════════════════════════════════╗"
            echo "║                   CLEANING UP ZOMBIE PROCESSES                  ║"
            echo "╚═════════════════════════════════════════════════════════════════╝"
            cleanup_all_zombies
            ;;
        del)
            if [ -z "$arg2" ]; then
                print_colored "$RED" "❌ Please specify an instance ID or 'all'"
                display_help
                exit 1
            fi
            delete_nockchain_instances "$arg2"
            ;;
        status)
            check_status
            ;;
        help|--help|-h)
            display_help
            ;;
        "")
            # No command provided, show help
            display_help
            ;;
        *)
            print_colored "$RED" "❌ Unknown command: $command"
            display_help
            exit 1
            ;;
    esac
}

# Run the main function
main "$@" 