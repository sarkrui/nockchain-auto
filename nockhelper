#!/bin/bash

set -e

# MINING_PUBKEY to be used in the nockchain command
MINING_PUBKEY="2cLQ54ec6Caq9C4mTZoSk2Kv4XjJ3vzhyDehgdvEQue6dXZPp9jAa2ZqsaJciB3ZZXomoCjGp53GiyVJNSx2KDn8ehmNGdWcqBsfosDCsAQLDSBW8KgaDDHL4ojiFMSMtHbc"

# Nockhelper version
NOCKHELPER_VERSION="1.1.0"

# Installation directory
INSTALL_DIR="$HOME/nockbin"
HELPER_SCRIPT="$INSTALL_DIR/nockhelper"
HELPER_REMOTE="https://raw.githubusercontent.com/sarkrui/nockchain-auto/refs/heads/master/nockhelper"

# OS-specific system bin directory
SYS_BIN_DIR=""
if [[ "$OSTYPE" == "darwin"* ]]; then
    SYS_BIN_DIR="/usr/local/bin"
else
    SYS_BIN_DIR="/usr/bin"
fi

# Environment variables for nockchain
NOCKCHAIN_ENV_VARS="export RUST_LOG=\"info,nockchain=debug,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info\" && export MINIMAL_LOG_FORMAT=\"true\""

# ANSI color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Function to apply colors to text
print_colored() {
    local color=$1
    local text=$2
    echo -e "${color}${text}${NC}"
}

# Function to check and kill zombie nockchain processes
kill_zombie_processes() {
    local instance_id=$1
    local process_name="nock-$instance_id"
    
    # Collect all PIDs for the process (there could be multiple instances or child processes)
    local pids=($(pgrep -f "$process_name" || echo ""))
    
    if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
        print_colored "$YELLOW" "ğŸ” Zombie process(es) for $process_name detected after screen session ended."
        print_colored "$YELLOW" "Found ${#pids[@]} process(es) to terminate."
        
        # Try graceful termination first (SIGTERM)
        print_colored "$YELLOW" "ğŸ›‘ Attempting graceful termination with SIGTERM..."
        for pid in "${pids[@]}"; do
            print_colored "$CYAN" "Sending SIGTERM to process $pid..."
            kill -15 "$pid" 2>/dev/null || true
        done
        
        # Wait a moment for processes to terminate
        sleep 2
        
        # Check if processes still exist and try SIGINT (like Ctrl+C)
        pids=($(pgrep -f "$process_name" || echo ""))
        if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
            print_colored "$YELLOW" "âš ï¸ Processes still running. Trying SIGINT (Ctrl+C)..."
            for pid in "${pids[@]}"; do
                print_colored "$CYAN" "Sending SIGINT to process $pid..."
                kill -2 "$pid" 2>/dev/null || true
            done
            
            # Wait again
            sleep 2
            
            # If still running, use force kill (SIGKILL)
            pids=($(pgrep -f "$process_name" || echo ""))
            if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
                print_colored "$RED" "âš ï¸ Processes still running. Forcing termination with SIGKILL..."
                for pid in "${pids[@]}"; do
                    print_colored "$RED" "Sending SIGKILL to process $pid..."
                    kill -9 "$pid" 2>/dev/null || true
                done
                
                # One final check
                sleep 1
                pids=($(pgrep -f "$process_name" || echo ""))
                if [ ${#pids[@]} -gt 0 ] && [ -n "${pids[0]}" ]; then
                    print_colored "$RED" "âŒ WARNING: Failed to terminate some processes for $process_name!"
                    print_colored "$RED" "PIDs still running: ${pids[*]}"
                    print_colored "$YELLOW" "You may need to manually terminate these processes with 'sudo kill -9 ${pids[*]}'"
                    return 1
                fi
            fi
        fi
        
        # Check if any child processes with similar names remain
        local child_pids=($(ps aux | grep -i "[n]ock" | grep -i "$instance_id" | awk '{print $2}' || echo ""))
        if [ ${#child_pids[@]} -gt 0 ] && [ -n "${child_pids[0]}" ]; then
            print_colored "$YELLOW" "Found ${#child_pids[@]} related child processes. Terminating..."
            for pid in "${child_pids[@]}"; do
                print_colored "$CYAN" "Killing child process $pid..."
                kill -9 "$pid" 2>/dev/null || true
            done
        fi
        
        print_colored "$GREEN" "âœ… Process cleanup for $process_name completed."
        
        # Check memory and clean up any leaked memory
        if command_exists sync; then
            sync
            if [[ "$(detect_os)" == "linux" ]] && [ -w /proc/sys/vm/drop_caches ]; then
                print_colored "$CYAN" "ğŸ§¹ Cleaning up system memory cache..."
                sudo sh -c "echo 1 > /proc/sys/vm/drop_caches" 2>/dev/null || true
            fi
        fi
    fi
}

# Function to clean up all zombie nockchain processes
cleanup_all_zombies() {
    print_colored "$YELLOW" "ğŸ” Searching for all zombie nockchain processes..."
    
    # First look for numbered instances
    local instance_pids=($(ps aux | grep -i "[n]ock-[0-9]" | awk '{print $2}' || echo ""))
    
    # Check if any of these don't have associated screen sessions
    if [ ${#instance_pids[@]} -gt 0 ] && [ -n "${instance_pids[0]}" ]; then
        for pid in "${instance_pids[@]}"; do
            local process=$(ps -p "$pid" -o comm= | grep -o "nock-[0-9]\+" || echo "")
            
            if [ -n "$process" ] && ! screen -list | grep -q "$process"; then
                print_colored "$RED" "âš ï¸ Found zombie process: $process (PID: $pid) with no screen session"
                
                # Extract the instance id
                if [[ $process =~ nock-([0-9]+) ]]; then
                    local instance_id="${BASH_REMATCH[1]}"
                    kill_zombie_processes "$instance_id"
                else
                    # If we can't extract an ID, just kill the process directly
                    print_colored "$RED" "Killing process $pid directly..."
                    kill -9 "$pid" 2>/dev/null || true
                fi
            fi
        done
    fi
    
    # Look for main nockchain process without screen
    if pgrep -f "nockchain" > /dev/null && ! screen -list | grep -q "nock[[:space:]]"; then
        print_colored "$RED" "âš ï¸ Found main nockchain process with no screen session"
        
        local main_pids=($(pgrep -f "nockchain" | grep -v "nock-" || echo ""))
        if [ ${#main_pids[@]} -gt 0 ] && [ -n "${main_pids[0]}" ]; then
            print_colored "$YELLOW" "Terminating ${#main_pids[@]} main nockchain processes..."
            
            # Try graceful termination first
            for pid in "${main_pids[@]}"; do
                print_colored "$CYAN" "Sending SIGTERM to process $pid..."
                kill -15 "$pid" 2>/dev/null || true
            done
            
            sleep 2
            
            # If still running, force kill
            main_pids=($(pgrep -f "nockchain" | grep -v "nock-" || echo ""))
            if [ ${#main_pids[@]} -gt 0 ] && [ -n "${main_pids[0]}" ]; then
                for pid in "${main_pids[@]}"; do
                    print_colored "$RED" "Forcing termination of process $pid..."
                    kill -9 "$pid" 2>/dev/null || true
                done
            fi
        fi
    fi
    
    # Final check for any remaining nockchain processes
    if pgrep -f "nock" > /dev/null; then
        print_colored "$YELLOW" "Some nockchain processes may still be running."
        print_colored "$YELLOW" "Run 'ps aux | grep nock' to check, or 'pkill -9 -f nock' to force terminate all."
    else
        print_colored "$GREEN" "âœ… All zombie nockchain processes have been terminated."
    fi
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to prompt for user confirmation
confirm() {
    print_colored "$YELLOW" "$1 [Y/n] "
    read -p "" response
    case "$response" in
        [nN][oO]|[nN]) 
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

# Function to check and install dependencies
check_dependencies() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    CHECKING DEPENDENCIES                         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    local os=$(detect_os)
    local missing_deps=()
    local deps=("curl" "git" "wget" "btop")
    
    # Check for missing dependencies
    for dep in "${deps[@]}"; do
        if ! command_exists "$dep"; then
            missing_deps+=("$dep")
        else
            print_colored "$GREEN" "âœ… $dep is already installed."
        fi
    done
    
    # Check for screen on Linux and macOS
    if ! command_exists screen; then
        print_colored "$YELLOW" "screen is required but not installed."
        if confirm "Would you like to install screen?"; then
            if [[ "$os" == "macos" ]]; then
                print_colored "$CYAN" "Installing screen using Homebrew..."
                brew install screen
            elif [[ "$os" == "linux" ]]; then
                print_colored "$CYAN" "Installing screen using system package manager..."
                if command_exists apt-get; then
                    sudo apt-get update
                    sudo apt-get install -y screen
                elif command_exists yum; then
                    sudo yum install -y screen
                else
                    print_colored "$RED" "Cannot automatically install screen. Please install it manually and try again."
                    return 1
                fi
            fi
            print_colored "$GREEN" "âœ… screen installed successfully."
        else
            print_colored "$YELLOW" "Screen installation skipped. Cannot run nockchain in background without screen."
            return 1
        fi
    else
        print_colored "$GREEN" "âœ… screen is already installed."
    fi
    
    # If all dependencies are installed
    if [ ${#missing_deps[@]} -eq 0 ]; then
        print_colored "$GREEN" "All dependencies are installed."
        return 0
    fi
    
    # Ask user to install missing dependencies
    print_colored "$YELLOW" "The following dependencies are missing: ${missing_deps[*]}"
    if ! confirm "Would you like to install them?"; then
        print_colored "$YELLOW" "Dependencies installation skipped. Some features may not work properly."
        return 1
    fi
    
    # Install missing dependencies based on OS
    if [[ "$os" == "macos" ]]; then
        if ! command_exists brew; then
            print_colored "$YELLOW" "Homebrew is required but was not found."
            if confirm "Would you like to install Homebrew?"; then
                /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            else
                print_colored "$YELLOW" "Homebrew installation skipped. Cannot install dependencies without Homebrew."
                return 1
            fi
        fi
        
        for dep in "${missing_deps[@]}"; do
            print_colored "$CYAN" "Installing $dep using Homebrew..."
            brew install "$dep"
        done
    elif [[ "$os" == "linux" ]]; then
        if command_exists apt-get; then
            print_colored "$CYAN" "Installing dependencies using apt-get..."
            sudo apt-get update
            sudo apt-get install -y "${missing_deps[@]}"
        elif command_exists yum; then
            print_colored "$CYAN" "Installing dependencies using yum..."
            sudo yum install -y "${missing_deps[@]}"
        else
            print_colored "$RED" "Cannot automatically install dependencies. Please install them manually and try again."
            return 1
        fi
    fi
    
    # Verify installation
    local still_missing=()
    for dep in "${missing_deps[@]}"; do
        if ! command_exists "$dep"; then
            still_missing+=("$dep")
        else
            print_colored "$GREEN" "âœ… $dep installed successfully."
        fi
    done
    
    if [ ${#still_missing[@]} -eq 0 ]; then
        print_colored "$GREEN" "All dependencies installed successfully."
        return 0
    else
        print_colored "$RED" "The following dependencies could not be installed: ${still_missing[*]}"
        print_colored "$YELLOW" "Please install them manually and try again."
        return 1
    fi
}

# Function to get the latest release tag from GitHub
get_latest_release_tag() {
    local repo="sarkrui/nockchain-auto"
    local tag=""
    
    if command_exists curl; then
        tag=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command_exists wget; then
        tag=$(wget -qO- "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    
    if [ -z "$tag" ]; then
        echo "unknown"
    else
        echo "$tag"
    fi
}

# Function to download/update release binaries
download_binaries() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                DOWNLOADING NOCKCHAIN BINARIES                   â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    # Check dependencies first
    check_dependencies
    
    local os=$(detect_os)
    local arch=$(detect_arch)
    local release_tag=$(get_latest_release_tag)
    
    echo "Detected: $os on $arch"
    echo "Latest release: $release_tag"
    
    # Create installation directory if it doesn't exist
    if [ ! -d "$INSTALL_DIR" ]; then
        echo "Creating installation directory: $INSTALL_DIR"
        mkdir -p "$INSTALL_DIR"
    fi
    
    # Set download URL based on OS and architecture
    local download_url="https://github.com/sarkrui/nockchain-auto/releases/latest/download/nockchain-all-$os-$arch.zip"
    local temp_zip="$INSTALL_DIR/nockchain-all-$os-$arch.zip"
    
    echo "Downloading nockchain binaries from: $download_url ($release_tag)"
    
    # Download the zip file
    if command_exists curl; then
        curl -L "$download_url" -o "$temp_zip"
    else
        wget "$download_url" -O "$temp_zip"
    fi
    
    if [ ! -f "$temp_zip" ]; then
        echo "Failed to download nockchain binaries"
        exit 1
    fi
    
    # Extract the zip file
    echo "Extracting binaries to $INSTALL_DIR"
    unzip -o "$temp_zip" -d "$INSTALL_DIR"
    
    # Make binaries executable
    echo "Making binaries executable"
    chmod +x "$INSTALL_DIR/nockchain-wallet" "$INSTALL_DIR/equix-latency" "$INSTALL_DIR/hoonc" "$INSTALL_DIR/nockchain" "$INSTALL_DIR/nockchain-bitcoin-sync"
    
    # Clean up
    echo "Cleaning up"
    rm "$temp_zip"
    
    echo "âœ… Download complete!"
    echo "ğŸ“‚ Nockchain binaries have been downloaded to: $INSTALL_DIR"
}

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    else
        echo "Unsupported operating system: $OSTYPE"
        exit 1
    fi
}

# Detect architecture
detect_arch() {
    local arch=$(uname -m)
    if [[ "$arch" == "x86_64" ]]; then
        echo "x86_64"
    elif [[ "$arch" == "arm64" ]] || [[ "$arch" == "aarch64" ]]; then
        echo "arm64"
    else
        echo "Unsupported architecture: $arch"
        exit 1
    fi
}

# Detect preferred shell for screen
detect_shell() {
    local os=$(detect_os)
    if [[ "$os" == "macos" ]] && command_exists zsh; then
        echo "zsh"
    else
        echo "bash"
    fi
}

# Get miner status
get_miner_status() {
    if ! command_exists screen; then
        print_colored "$RED" "ğŸ“› Screen not installed"
        return
    fi
    
    # Check for single miner instance
    if screen -list | grep -q "nock$"; then
        print_colored "$GREEN" "âœ… Default miner is RUNNING in screen session 'nock'"
    else
        print_colored "$RED" "âŒ Default miner is NOT running"
    fi
    
    # Check for batch instances
    local batch_count=0
    local batch_list=""
    
    while read -r line; do
        if [[ $line =~ nock-([0-9]+) ]]; then
            batch_count=$((batch_count+1))
            batch_list="${batch_list}nock-${BASH_REMATCH[1]}, "
        fi
    done < <(screen -list | grep -o "nock-[0-9]\+")
    
    if [ $batch_count -gt 0 ]; then
        # Remove trailing comma and space
        batch_list=${batch_list%, }
        print_colored "$GREEN" "âœ… $batch_count batch miner instances RUNNING: $batch_list"
    fi
    
    # Check for zombie processes (nock-N processes without matching screen sessions)
    local zombie_count=0
    local zombie_list=""
    
    for proc in $(pgrep -f "nock-[0-9]+" | sort); do
        local proc_name=$(ps -p "$proc" -o comm= | grep -o "nock-[0-9]\+")
        if [[ -n "$proc_name" ]] && ! screen -list | grep -q "$proc_name"; then
            zombie_count=$((zombie_count+1))
            zombie_list="${zombie_list}${proc_name}(PID:$proc), "
        fi
    done
    
    if [ $zombie_count -gt 0 ]; then
        # Remove trailing comma and space
        zombie_list=${zombie_list%, }
        print_colored "$RED" "âš ï¸ $zombie_count zombie miner processes detected: $zombie_list"
        print_colored "$YELLOW" "   Run 'nockhelper list' to manage these processes."
    fi
}

# Install the script globally
install_helper_globally() {
    local os=$(detect_os)
    local install_path=""
    
    # Determine installation path based on OS
    if [[ "$os" == "macos" ]]; then
        install_path="$SYS_BIN_DIR/nockhelper"
    else
        install_path="$SYS_BIN_DIR/nockhelper"
    fi
    
    # First try to download the latest helper script from remote
    if command_exists curl; then
        echo "Downloading latest helper script from remote..."
        if curl -s --head --fail "$HELPER_REMOTE" >/dev/null; then
            echo "Copying helper script to $install_path..."
            if [[ "$os" == "macos" ]]; then
                curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            if [ -f "$install_path" ]; then
                sudo chmod +x "$install_path"
                echo "âœ… Helper script installed to $install_path."
            else
                echo "âŒ Failed to install helper script to $install_path. Using local copy in $INSTALL_DIR."
                cp "$0" "$HELPER_SCRIPT"
                chmod +x "$HELPER_SCRIPT"
            fi
        else
            echo "â„¹ï¸ Helper script not found at remote URL. Using local copy."
            cp "$0" "$HELPER_SCRIPT"
            chmod +x "$HELPER_SCRIPT"
            
            if [[ "$os" == "macos" ]]; then
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            sudo chmod +x "$install_path"
        fi
    elif command_exists wget; then
        echo "Downloading latest helper script from remote..."
        if wget --spider "$HELPER_REMOTE" 2>/dev/null; then
            echo "Copying helper script to $install_path..."
            if [[ "$os" == "macos" ]]; then
                wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT"
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            if [ -f "$install_path" ]; then
                sudo chmod +x "$install_path"
                echo "âœ… Helper script installed to $install_path."
            else
                echo "âŒ Failed to install helper script to $install_path. Using local copy in $INSTALL_DIR."
                cp "$0" "$HELPER_SCRIPT"
                chmod +x "$HELPER_SCRIPT"
            fi
        else
            echo "â„¹ï¸ Helper script not found at remote URL. Using local copy."
            cp "$0" "$HELPER_SCRIPT"
            chmod +x "$HELPER_SCRIPT"
            
            if [[ "$os" == "macos" ]]; then
                sudo cp "$HELPER_SCRIPT" "$install_path"
            else
                sudo cp "$HELPER_SCRIPT" "$install_path"
            fi
            sudo chmod +x "$install_path"
        fi
    else
        echo "Neither curl nor wget found. Using local copy."
        cp "$0" "$HELPER_SCRIPT"
        chmod +x "$HELPER_SCRIPT"
        
        if [[ "$os" == "macos" ]]; then
            sudo cp "$HELPER_SCRIPT" "$install_path"
        else
            sudo cp "$HELPER_SCRIPT" "$install_path"
        fi
        sudo chmod +x "$install_path"
    fi
    
    echo "nockhelper installed globally at $install_path. Binaries will be in $INSTALL_DIR."
}

# Function to get the installed nockchain version
get_installed_nockchain_version() {
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        echo "not_installed"
        return
    fi
    
    # Try to get version from nockchain binary
    local version=$("$INSTALL_DIR/nockchain" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)
    
    # If that fails, try to get a timestamp from the binary
    if [ -z "$version" ]; then
        local file_date=$(stat -c %y "$INSTALL_DIR/nockchain" 2>/dev/null || stat -f "%Sm" "$INSTALL_DIR/nockchain" 2>/dev/null)
        if [ -n "$file_date" ]; then
            echo "unknown (installed on $file_date)"
            return
        else
            echo "unknown"
            return
        fi
    fi
    
    echo "$version"
}

# Function to get the installed nockhelper version
get_installed_nockhelper_version() {
    # Return the version defined at the top of the script
    echo "$NOCKHELPER_VERSION"
}

# Function to get the latest nockhelper version from GitHub
get_latest_nockhelper_version() {
    local repo="sarkrui/nockchain-auto"
    local tag=""
    
    if command_exists curl; then
        tag=$(curl -s "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    elif command_exists wget; then
        tag=$(wget -qO- "https://api.github.com/repos/$repo/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
    fi
    
    if [ -z "$tag" ]; then
        echo "unknown"
    else
        echo "$tag"
    fi
}

# Function to compare versions
version_gt() {
    test "$(printf '%s\n' "$1" "$2" | sort -V | head -n 1)" != "$1"
}

# Function to check for nockchain updates
check_for_nockchain_updates() {
    local installed_version=$(get_installed_nockchain_version)
    local latest_version=$(get_latest_release_tag)
    
    if [ "$installed_version" = "not_installed" ]; then
        echo "â„¹ï¸ Nockchain is not installed."
        return 1
    fi
    
    echo "Nockchain:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # If either version is unknown, we can't compare
    if [[ "$installed_version" == *"unknown"* ]] || [[ "$latest_version" == "unknown" ]]; then
        echo "â„¹ï¸ Cannot determine if a nockchain update is needed."
        return 2
    fi
    
    # Remove 'v' prefix if present
    installed_version=${installed_version#v}
    latest_version=${latest_version#v}
    
    if version_gt "$latest_version" "$installed_version"; then
        echo "âœ… Nockchain update available! Version $latest_version is newer than your installed version $installed_version."
        return 0
    else
        echo "âœ… You have the latest nockchain version ($installed_version)."
        return 3
    fi
}

# Function to check for nockhelper updates
check_for_nockhelper_updates() {
    local installed_version=$(get_installed_nockhelper_version)
    local latest_version=$(get_latest_nockhelper_version)
    
    echo "Nockhelper:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # If either version is unknown, we can't compare
    if [[ "$installed_version" == *"unknown"* ]] || [[ "$latest_version" == "unknown" ]]; then
        echo "â„¹ï¸ Cannot determine if a nockhelper update is needed."
        return 2
    fi
    
    # Remove 'v' prefix if present
    installed_version=${installed_version#v}
    latest_version=${latest_version#v}
    
    if version_gt "$latest_version" "$installed_version"; then
        echo "âœ… Nockhelper update available! Version $latest_version is newer than your installed version $installed_version."
        return 0
    else
        echo "âœ… You have the latest nockhelper version ($installed_version)."
        return 3
    fi
}

# Function to check for all updates
check_for_updates() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     CHECKING FOR UPDATES                        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    check_for_nockchain_updates
    echo ""
    check_for_nockhelper_updates
    
    return 0
}

# Function to delete nockchain instance directories
delete_nockchain_instances() {
    local instance_id=$1
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                 DELETING NOCKCHAIN INSTANCES                    â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if [ "$instance_id" = "all" ]; then
        print_colored "$YELLOW" "Deleting all nockchain instance directories..."
        
        # Check if any instance directories exist
        local count=0
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ]; then
                count=$((count+1))
            fi
        done
        
        if [ $count -eq 0 ]; then
            print_colored "$RED" "âŒ No nockchain instance directories found."
            return 1
        fi
        
        # Confirm deletion of all instances
        if ! confirm "Are you sure you want to delete all $count nockchain instance directories?"; then
            print_colored "$BLUE" "Deletion cancelled."
            return 0
        fi
        
        # Stop all running instances first
        if command_exists screen; then
            while read -r line; do
                if [[ $line =~ nock-([0-9]+) ]]; then
                    local session="nock-${BASH_REMATCH[1]}"
                    local instance_num="${BASH_REMATCH[1]}"
                    print_colored "$YELLOW" "Stopping screen session $session..."
                    # First try to gracefully terminate the nockchain process
                    screen -S "$session" -X stuff $'\003'  # Send Ctrl+C
                    sleep 1
                    # Then quit the screen session
                    screen -S "$session" -X quit 2>/dev/null || true
                    
                    # Kill any zombie processes
                    kill_zombie_processes "$instance_num"
                fi
            done < <(screen -list | grep -o "nock-[0-9]\+")
        fi
        
        # Delete all instance directories
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ]; then
                print_colored "$YELLOW" "Removing $dir..."
                rm -rf "$dir"
            fi
        done
        
        print_colored "$GREEN" "âœ… All nockchain instance directories have been deleted."
    else
        # Check if instance_id includes "nock-" prefix
        local screen_name=""
        local instance_dir=""
        local instance_num=""
        
        if [[ "$instance_id" == nock-* ]]; then
            # Format is nock-N
            screen_name="$instance_id"
            instance_num="${BASH_REMATCH[1]}"
            instance_dir="$INSTALL_DIR/$instance_id"
        elif [[ "$instance_id" =~ ^[0-9]+$ ]]; then
            # Format is just N
            instance_num="$instance_id"
            screen_name="nock-$instance_id"
            instance_dir="$INSTALL_DIR/$screen_name"
        else
            print_colored "$RED" "âŒ Invalid instance ID format. Use 'nock-N', 'N', or 'all'."
            return 1
        fi
        
        if [ ! -d "$instance_dir" ]; then
            print_colored "$RED" "âŒ Nockchain instance directory not found: $instance_dir"
            return 1
        fi
        
        # Confirm deletion of specific instance
        if ! confirm "Are you sure you want to delete nockchain instance $screen_name?"; then
            print_colored "$BLUE" "Deletion cancelled."
            return 0
        fi
        
        # Stop the running instance first
        if command_exists screen; then
            if screen -list | grep -q "$screen_name"; then
                print_colored "$YELLOW" "Stopping screen session $screen_name..."
                
                # First try to gracefully terminate the nockchain process with Ctrl+C
                print_colored "$YELLOW" "Sending termination signal to nockchain process..."
                screen -S "$screen_name" -X stuff $'\003'  # Send Ctrl+C
                
                # Give it a moment to shut down
                sleep 2
                
                # Now quit the screen session
                print_colored "$YELLOW" "Terminating screen session..."
                screen -S "$screen_name" -X quit 2>/dev/null || true
                
                # Kill any zombie processes
                kill_zombie_processes "$instance_num"
                
                # Wait a bit to ensure the screen session is fully terminated
                sleep 1
            else
                print_colored "$YELLOW" "No running screen session found for $screen_name."
            fi
        fi
        
        # Delete instance directory
        print_colored "$YELLOW" "Removing $instance_dir..."
        rm -rf "$instance_dir"
        
        print_colored "$GREEN" "âœ… Nockchain instance $screen_name has been deleted."
    fi
    
    return 0
}

# List and manage screen sessions
list_screen_sessions() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                  NOCKCHAIN SCREEN SESSIONS                      â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if ! command_exists screen; then
        print_colored "$RED" "âŒ screen is not installed."
        return 1
    fi
    
    # Get all nockchain-related screen sessions
    local sessions=()
    local i=0
    
    # Check for default nock session
    if screen -list | grep -q "nock[[:space:]]"; then
        sessions[$i]="nock"
        i=$((i+1))
    fi
    
    # Check for batch instances
    while read -r line; do
        if [[ $line =~ nock-([0-9]+) ]]; then
            sessions[$i]="${BASH_REMATCH[0]}"
            i=$((i+1))
        fi
    done < <(screen -list | grep -o "nock-[0-9]\+")
    
    # Display sessions
    if [ ${#sessions[@]} -eq 0 ]; then
        print_colored "$YELLOW" "No nockchain screen sessions found."
        return 0
    fi
    
    print_colored "$GREEN" "Found ${#sessions[@]} nockchain screen sessions:"
    echo ""
    
    for ((i=0; i<${#sessions[@]}; i++)); do
        print_colored "$CYAN" "  [${BOLD}$((i+1))${NC}${CYAN}] ${sessions[$i]}"
    done
    
    echo ""
    print_colored "$MAGENTA" "What would you like to do?"
    print_colored "$CYAN" "  [${BOLD}a${NC}${CYAN}] Attach to a session"
    print_colored "$CYAN" "  [${BOLD}k${NC}${CYAN}] Kill (stop) a session"
    print_colored "$CYAN" "  [${BOLD}v${NC}${CYAN}] View session logs"
    print_colored "$CYAN" "  [${BOLD}q${NC}${CYAN}] Quit this menu"
    
    read -p "Enter your choice [a/k/v/q]: " choice
    
    case "$choice" in
        a|A)
            read -p "Enter session number to attach to: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$GREEN" "Attaching to session ${sessions[$((session_num-1))]}..."
                exec screen -r "${sessions[$((session_num-1))]}"
            else
                print_colored "$RED" "âŒ Invalid session number."
            fi
            ;;
        k|K)
            read -p "Enter session number to kill: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$YELLOW" "Killing session ${sessions[$((session_num-1))]}..."
                # First try to gracefully terminate the nockchain process
                screen -S "${sessions[$((session_num-1))]}" -X stuff $'\003'  # Send Ctrl+C
                sleep 1
                # Then quit the screen session
                screen -S "${sessions[$((session_num-1))]}" -X quit 2>/dev/null || true
                
                # Check if it's a batch instance and kill any zombie processes
                if [[ "${sessions[$((session_num-1))]}" =~ nock-([0-9]+) ]]; then
                    local instance_id="${BASH_REMATCH[1]}"
                    kill_zombie_processes "$instance_id"
                fi
                
                print_colored "$GREEN" "âœ… Session terminated."
            else
                print_colored "$RED" "âŒ Invalid session number."
            fi
            ;;
        v|V)
            read -p "Enter session number to view logs: " session_num
            if [[ "$session_num" =~ ^[0-9]+$ ]] && [ "$session_num" -gt 0 ] && [ "$session_num" -le ${#sessions[@]} ]; then
                print_colored "$GREEN" "Viewing logs for session ${sessions[$((session_num-1))]}..."
                screen -S "${sessions[$((session_num-1))]}" -X hardcopy "/tmp/nockchain_screen_log"
                if [ -f "/tmp/nockchain_screen_log" ]; then
                    less "/tmp/nockchain_screen_log"
                    rm "/tmp/nockchain_screen_log"
                else
                    print_colored "$RED" "âŒ Failed to capture logs."
                fi
            else
                print_colored "$RED" "âŒ Invalid session number."
            fi
            ;;
        q|Q)
            print_colored "$BLUE" "Exiting menu."
            ;;
        *)
            print_colored "$RED" "âŒ Invalid choice."
            ;;
    esac
    
    return 0
}

# Display help message
display_help() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                      NOCKCHAIN HELPER TOOL                      â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    print_colored "$MAGENTA" "CURRENT STATUS:"
    print_colored "$MAGENTA" "â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯"
    print_colored "$CYAN" "ğŸ“‚ Install Location: $INSTALL_DIR"
    print_colored "$CYAN" "ğŸ› ï¸ Nockhelper: $(get_installed_nockhelper_version)"
    
    # Skip update check when displaying help to avoid GitHub API rate limits
    print_colored "$CYAN" "ğŸ”„ Nockhelper Update Status: Use 'nockhelper check' to check for updates"
    
    if [ -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$GREEN" "ğŸ“¦ Nockchain: Installed ($(get_installed_nockchain_version))"
        print_colored "$CYAN" "ğŸ”„ Nockchain Update Status: Use 'nockhelper check' to check for updates"
    else
        print_colored "$RED" "ğŸ“¦ Nockchain: Not installed"
    fi
    get_miner_status
    echo ""
    echo ""
    
    print_colored "$MAGENTA" "COMMANDS:"
    print_colored "$MAGENTA" "â¯â¯â¯â¯â¯â¯â¯â¯â¯"
    print_colored "$YELLOW" "  ${BOLD}install${NC}    - Install nockchain binaries"
    print_colored "$CYAN" "               Usage: nockhelper install"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update${NC}     - Update nockchain binaries and helper script"
    print_colored "$CYAN" "               Usage: nockhelper update"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update-nockchain${NC} - Update nockchain binaries"
    print_colored "$CYAN" "               Usage: nockhelper update-nockchain"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}update-nockhelper${NC} - Update nockhelper script"
    print_colored "$CYAN" "               Usage: nockhelper update-nockhelper"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}download${NC}   - Download/update nockchain binaries from latest release"
    print_colored "$CYAN" "               Usage: nockhelper download"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}check${NC}      - Check for nockchain updates"
    print_colored "$CYAN" "               Usage: nockhelper check"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}run${NC}        - Run nockchain miner in a screen session"
    print_colored "$CYAN" "               Usage: nockhelper run"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}run <N>${NC}    - Run N instances of nockchain miners in separate screen sessions"
    print_colored "$CYAN" "               Usage: nockhelper run 10"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}list${NC}       - List and manage nockchain screen sessions"
    print_colored "$CYAN" "               Usage: nockhelper list"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}cleanup${NC}    - Clean up all zombie nockchain processes"
    print_colored "$CYAN" "               Usage: nockhelper cleanup"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}del <id>${NC}   - Delete a specific nockchain instance directory"
    print_colored "$CYAN" "               Usage: nockhelper del 1"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}del all${NC}    - Delete all nockchain instance directories"
    print_colored "$CYAN" "               Usage: nockhelper del all"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}uninstall${NC}  - Remove nockchain installation"
    print_colored "$CYAN" "               Usage: nockhelper uninstall"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}status${NC}     - Check miner status"
    print_colored "$CYAN" "               Usage: nockhelper status"
    echo ""
    print_colored "$YELLOW" "  ${BOLD}help${NC}       - Display this help message"
    print_colored "$CYAN" "               Usage: nockhelper help"
    echo ""
    
    print_colored "$MAGENTA" "SCREEN MANAGEMENT:"
    print_colored "$MAGENTA" "â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯"
    print_colored "$CYAN" "  To attach to running miner:  ${BOLD}screen -r nock${NC}"
    print_colored "$CYAN" "  To detach from session:      Press ${BOLD}Ctrl+A${NC}, then ${BOLD}D${NC}"
    print_colored "$CYAN" "  To stop the miner:           ${BOLD}screen -S nock -X quit${NC}"
    echo ""
    
    print_colored "$MAGENTA" "ENVIRONMENT:"
    print_colored "$MAGENTA" "â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯"
    print_colored "$CYAN" "  Operating System: $(detect_os)"
    print_colored "$CYAN" "  Architecture:     $(detect_arch)"
    print_colored "$CYAN" "  Preferred Shell:  $(detect_shell)"
    echo ""
    
    print_colored "$GREEN" "For more information, visit: https://github.com/sarkrui/nockchain-auto"
}

# Check status
check_status() {
    # Check dependencies first
    check_dependencies
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                        NOCKCHAIN STATUS                         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    print_colored "$CYAN" "ğŸ› ï¸ Nockhelper version: $(get_installed_nockhelper_version)"
    
    if [ -d "$INSTALL_DIR" ]; then
        print_colored "$GREEN" "ğŸ“‚ Installation directory: $INSTALL_DIR (exists)"
    else
        print_colored "$RED" "ğŸ“‚ Installation directory: $INSTALL_DIR (missing)"
    fi
    
    if [ -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$GREEN" "ğŸ“¦ Nockchain binary: Found and executable"
        print_colored "$CYAN" "ğŸ“¦ Nockchain version: $(get_installed_nockchain_version)"
        check_for_nockchain_updates
    else
        print_colored "$RED" "ğŸ“¦ Nockchain binary: Not found or not executable"
    fi
    
    get_miner_status
    
    # Check for zombie processes not associated with any screen session
    local zombie_procs=$(pgrep -f "nock-[0-9]+" | wc -l)
    local screen_sessions=$(screen -list 2>/dev/null | grep -c "nock-[0-9]\+")
    
    # If there are more processes than screen sessions, we have zombies
    if [ "$zombie_procs" -gt "$screen_sessions" ] && [ "$zombie_procs" -gt 0 ]; then
        print_colored "$RED" "âš ï¸ Detected potential zombie nockchain processes!"
        print_colored "$YELLOW" "   Run 'ps aux | grep nock-' to see them"
        print_colored "$YELLOW" "   Use 'nockhelper cleanup' to terminate all zombie processes"
    fi
    
    # Check for batch miner instances directories
    if [ -d "$INSTALL_DIR" ]; then
        local batch_dirs=0
        for dir in "$INSTALL_DIR"/nock-*; do
            if [ -d "$dir" ] && [ -x "$dir/nock-"* ]; then
                batch_dirs=$((batch_dirs+1))
            fi
        done
        
        if [ $batch_dirs -gt 0 ]; then
            print_colored "$CYAN" "ğŸ“¦ Batch miner instance directories found: $batch_dirs"
        fi
    fi
    
    if command_exists screen; then
        # Commands for single instance
        if screen -list | grep -q "nock$"; then
            echo ""
            print_colored "$MAGENTA" "Default Miner Control Commands:"
            print_colored "$CYAN" "  Attach to miner: ${BOLD}screen -r nock${NC}"
            print_colored "$CYAN" "  Stop miner:      ${BOLD}screen -S nock -X quit${NC}"
        fi
        
        # Commands for batch instances
        local batch_running=0
        while read -r line; do
            if [[ $line =~ nock-([0-9]+) ]]; then
                batch_running=$((batch_running+1))
            fi
        done < <(screen -list | grep -o "nock-[0-9]\+")
        
        if [ $batch_running -gt 0 ]; then
            echo ""
            print_colored "$MAGENTA" "Batch Miners Control Commands:"
            print_colored "$CYAN" "  List all sessions:      ${BOLD}screen -ls${NC}"
            print_colored "$CYAN" "  Attach to miner #N:     ${BOLD}screen -r nock-N${NC}"
            print_colored "$CYAN" "  Stop miner #N:          ${BOLD}screen -S nock-N -X quit${NC}"
            print_colored "$CYAN" "  Stop all batch miners:  ${BOLD}for i in \$(screen -ls | grep nock- | awk '{print \$1}'); do screen -S \$i -X quit; done${NC}"
        fi
    fi
}

# Install nockchain
install_nockchain() {
    # Check dependencies first
    check_dependencies
    
    local os=$(detect_os)
    local arch=$(detect_arch)
    local release_tag=$(get_latest_release_tag)
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                   NOCKCHAIN INSTALLATION WIZARD                 â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Detected: $os on $arch"
    echo "Latest release: $release_tag"

    # Install screen using Homebrew on macOS
    if [[ "$os" == "macos" ]]; then
        if ! command_exists brew; then
            echo "Homebrew is required but was not found."
            if confirm "Would you like to install Homebrew?"; then
                /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
            else
                echo "Homebrew installation skipped. Cannot continue without Homebrew."
                exit 1
            fi
        fi
        
        if ! command_exists screen; then
            if confirm "Screen is required but not installed. Would you like to install screen?"; then
                echo "Installing screen using Homebrew..."
                brew install screen
            else
                echo "Screen installation skipped. Cannot run nockchain in background without screen."
            fi
        else
            echo "âœ… screen is already installed."
        fi
    fi

    # Check if download tools are available
    if ! command_exists curl && ! command_exists wget; then
        echo "Either curl or wget is required but neither was found. Please install one of them and try again."
        exit 1
    fi

    # Check if unzip is installed
    if ! command_exists unzip; then
        echo "unzip is required but was not found."
        if confirm "Would you like to install unzip?"; then
            if [[ "$os" == "macos" ]]; then
                brew install unzip
            elif [[ "$os" == "linux" ]]; then
                if command_exists apt-get; then
                    sudo apt-get install -y unzip
                elif command_exists yum; then
                    sudo yum install -y unzip
                else
                    echo "Cannot automatically install unzip. Please install it manually and try again."
                    exit 1
                fi
            fi
        else
            echo "Unzip installation skipped. Cannot continue without unzip."
            exit 1
        fi
    fi

    # Confirm installation
    if ! confirm "Ready to install nockchain to $INSTALL_DIR. Continue?"; then
        echo "Installation aborted by user."
        exit 0
    fi

    # Create installation directory if it doesn't exist
    if [ ! -d "$INSTALL_DIR" ]; then
        echo "Creating installation directory: $INSTALL_DIR"
        mkdir -p "$INSTALL_DIR"
    fi

    # Set download URL based on OS and architecture
    local download_url="https://github.com/sarkrui/nockchain-auto/releases/latest/download/nockchain-all-$os-$arch.zip"
    local temp_zip="$INSTALL_DIR/nockchain-all-$os-$arch.zip"

    echo "Downloading nockchain binaries from: $download_url ($release_tag)"
    
    # Download the zip file
    if command_exists curl; then
        curl -L "$download_url" -o "$temp_zip"
    else
        wget "$download_url" -O "$temp_zip"
    fi

    if [ ! -f "$temp_zip" ]; then
        echo "Failed to download nockchain binaries"
        exit 1
    fi

    # Extract the zip file
    echo "Extracting binaries to $INSTALL_DIR"
    unzip -o "$temp_zip" -d "$INSTALL_DIR"

    # Make binaries executable
    echo "Making binaries executable"
    chmod +x "$INSTALL_DIR/nockchain-wallet" "$INSTALL_DIR/equix-latency" "$INSTALL_DIR/hoonc" "$INSTALL_DIR/nockchain" "$INSTALL_DIR/nockchain-bitcoin-sync"

    # Clean up
    echo "Cleaning up"
    rm "$temp_zip"
    
    # Install helper script globally
    install_helper_globally

    echo "âœ… Installation complete!"
    echo "ğŸ“‚ Nockchain binaries have been installed to: $INSTALL_DIR"
    echo ""
    echo "ğŸ’¡ Next steps:"
    echo "   - Start mining: nockhelper run"
    echo "   - View help: nockhelper help"
}

# Update nockchain
update_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     UPDATING NOCKCHAIN                          â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    local installed_version=$(get_installed_nockchain_version)
    local latest_version=$(get_latest_release_tag)
    
    echo "Nockchain:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # Check if update is needed
    if [[ "$installed_version" != "not_installed" ]] && [[ "$installed_version" != *"unknown"* ]] && [[ "$latest_version" != "unknown" ]]; then
        # Remove 'v' prefix if present
        installed_version=${installed_version#v}
        latest_version=${latest_version#v}
        
        if ! version_gt "$latest_version" "$installed_version"; then
            echo "â„¹ï¸ You already have the latest nockchain version ($installed_version)."
            if ! confirm "Do you want to continue with the nockchain update anyway?"; then
                echo "Nockchain update cancelled."
                update_nockhelper
                return
            fi
        fi
    fi
    
    # Update binaries
    install_nockchain
    
    echo "âœ… Nockchain update complete!"
}

# Update nockhelper
update_nockhelper() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     UPDATING NOCKHELPER                         â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    local installed_version=$(get_installed_nockhelper_version)
    local latest_version=$(get_latest_nockhelper_version)
    
    echo "Nockhelper:"
    echo "  Installed version: $installed_version"
    echo "  Latest version:    $latest_version"
    
    # Check if update is needed
    if [[ "$latest_version" != "unknown" ]]; then
        # Remove 'v' prefix if present
        installed_version=${installed_version#v}
        latest_version=${latest_version#v}
        
        if ! version_gt "$latest_version" "$installed_version"; then
            echo "â„¹ï¸ You already have the latest nockhelper version ($installed_version)."
            if ! confirm "Do you want to continue with the nockhelper update anyway?"; then
                echo "Nockhelper update cancelled."
                return
            fi
        fi
    fi
    
    # Try to download the latest helper script
    if command_exists curl; then
        if curl -s --head --fail "$HELPER_REMOTE" >/dev/null; then
            echo "Updating helper script..."
            curl -L "$HELPER_REMOTE" -o "$HELPER_SCRIPT.new"
            if [ -f "$HELPER_SCRIPT.new" ]; then
                chmod +x "$HELPER_SCRIPT.new"
                mv "$HELPER_SCRIPT.new" "$HELPER_SCRIPT"
                echo "âœ… Helper script updated."
                # Execute the updated script for the rest of the update
                exec "$HELPER_SCRIPT" update
                exit 0
            else
                echo "âŒ Failed to download updated helper script."
            fi
        else
            echo "â„¹ï¸ Helper script not found at remote URL."
        fi
    elif command_exists wget; then
        if wget --spider "$HELPER_REMOTE" 2>/dev/null; then
            echo "Updating helper script..."
            wget -q "$HELPER_REMOTE" -O "$HELPER_SCRIPT.new"
            if [ -f "$HELPER_SCRIPT.new" ]; then
                chmod +x "$HELPER_SCRIPT.new"
                mv "$HELPER_SCRIPT.new" "$HELPER_SCRIPT"
                echo "âœ… Helper script updated."
                # Execute the updated script for the rest of the update
                exec "$HELPER_SCRIPT" update
                exit 0
            else
                echo "âŒ Failed to download updated helper script."
            fi
        else
            echo "â„¹ï¸ Helper script not found at remote URL."
        fi
    else
        echo "âŒ Neither curl nor wget found. Cannot update helper script."
    fi
    
    echo "âœ… Nockhelper update complete!"
}

# Update both nockchain and nockhelper
update_all() {
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                     UPDATING ALL COMPONENTS                     â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    update_nockhelper
    echo ""
    update_nockchain
    
    echo "âœ… All updates complete!"
}

# Uninstall nockchain
uninstall_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    UNINSTALLING NOCKCHAIN                       â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if ! confirm "Are you sure you want to uninstall nockchain from $INSTALL_DIR?"; then
        echo "Uninstall cancelled."
        return
    fi
    
    echo "Uninstalling nockchain..."
    
    # Stop any running nockchain screen sessions
    if command_exists screen; then
        if screen -list | grep -q "nock"; then
            echo "Stopping nockchain screen sessions..."
            screen -S nock -X quit 2>/dev/null || true
        fi
    fi
    
    # Remove installation directory
    if [ -d "$INSTALL_DIR" ]; then
        echo "Removing installation directory: $INSTALL_DIR"
        rm -rf "$INSTALL_DIR"
    fi
    
    # Remove from PATH in shell config
    local os=$(detect_os)
    if [[ "$os" == "macos" ]]; then
        local shell_rc="$HOME/.zshrc"
        if [ -f "$shell_rc" ]; then
            echo "Removing from $shell_rc..."
            sed -i'.bak' '/# Added by nockhelper installer/d' "$shell_rc"
            sed -i'.bak' '/export PATH="\$PATH:\/Users\/.*\/nockbin"/d' "$shell_rc"
            rm -f "$shell_rc.bak"
        fi
    else
        local shell_rc="$HOME/.bashrc"
        if [ -f "$shell_rc" ]; then
            echo "Removing from $shell_rc..."
            sed -i '/# Added by nockhelper installer/d' "$shell_rc"
            sed -i '/export PATH="\$PATH:\/home\/.*\/nockbin"/d' "$shell_rc"
        fi
    fi
    
    echo "âœ… Uninstall complete! Please restart your terminal or source your shell config."
}

# Run nockchain miner in screen
run_nockchain() {
    # Check dependencies first
    check_dependencies
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘                    STARTING NOCKCHAIN MINER                     â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if ! command_exists screen; then
        print_colored "$RED" "âŒ screen is not installed. Cannot run nockchain in the background."
        return 1
    fi
    
    # Check if there's already a nockchain screen session
    if screen -list | grep -q "nock"; then
        print_colored "$YELLOW" "â„¹ï¸ nockchain is already running in a screen session."
        print_colored "$CYAN" "   To attach to it, run: screen -r nock"
        print_colored "$CYAN" "   To kill it, run: screen -S nock -X quit"
        return 0
    fi
    
    # Make sure nockchain is installed
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$RED" "âŒ nockchain binary not found or not executable."
        print_colored "$YELLOW" "   Please run 'nockhelper install' first."
        return 1
    fi
    
    print_colored "$CYAN" "Starting nockchain miner in a screen session..."
    
    # Detect preferred shell
    local shell=$(detect_shell)
    
    # For Linux, set vm.overcommit_memory=1
    local os=$(detect_os)
    if [[ "$os" == "linux" ]]; then
        print_colored "$YELLOW" "Setting vm.overcommit_memory=1 for Linux..."
        sudo sysctl -w vm.overcommit_memory=1
    fi
    
    # Create a wrapper script to handle cleanup when the screen session ends
    local wrapper_script="$INSTALL_DIR/start_nockchain.sh"
    
    cat > "$wrapper_script" << EOF
#!/bin/bash
# Wrapper script for main nockchain instance

# Store process IDs
export MAIN_PID=\$$
echo "\$MAIN_PID" > "$INSTALL_DIR/.nockchain_main_pid"

# Function to clean up when the script exits
cleanup() {
    echo "Cleaning up nockchain process..."
    
    # Get all child processes
    local children=\$(pgrep -P \$MAIN_PID 2>/dev/null || echo "")
    local grandchildren=""
    
    # For each child, get its children too
    for child in \$children; do
        local child_procs=\$(pgrep -P \$child 2>/dev/null || echo "")
        if [ -n "\$child_procs" ]; then
            grandchildren="\$grandchildren \$child_procs"
        fi
    done
    
    # Combine all processes
    local all_procs="\$children \$grandchildren"
    
    # Try graceful termination first
    if [ -n "\$all_procs" ]; then
        echo "Sending SIGTERM to child processes: \$all_procs"
        kill -15 \$all_procs 2>/dev/null || true
        sleep 2
        
        # Check if any processes still running
        local still_running=""
        for pid in \$all_procs; do
            if kill -0 \$pid 2>/dev/null; then
                still_running="\$still_running \$pid"
            fi
        done
        
        # If still running, force kill
        if [ -n "\$still_running" ]; then
            echo "Forcing termination of processes: \$still_running"
            kill -9 \$still_running 2>/dev/null || true
        fi
    fi
    
    # Also look for any remaining nockchain process directly
    local nock_procs=\$(pgrep -f "nockchain" | grep -v "\$MAIN_PID" || echo "")
    if [ -n "\$nock_procs" ]; then
        echo "Terminating nockchain processes: \$nock_procs"
        kill -15 \$nock_procs 2>/dev/null || true
        sleep 1
        kill -9 \$nock_procs 2>/dev/null || true
    fi
    
    # Clean up PID file
    rm -f "$INSTALL_DIR/.nockchain_main_pid"
    
    echo "Cleanup completed."
}

# Cleanup when any signal is received
trap cleanup EXIT SIGINT SIGTERM

# Change to installation directory
cd $INSTALL_DIR

# Clean up any previous data
rm -rf ./.data.nockchain .socket/nockchain_npc.sock

# Start the nockchain process
exec ./nockchain --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.108.123.225/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --peer /ip4/34.95.155.151/udp/30000/quic-v1 --peer /ip4/34.18.98.38/udp/30000/quic-v1
EOF

    chmod +x "$wrapper_script"
    
    # Create the screen session with the wrapper script
    screen -dmS nock $shell -c "$wrapper_script; exec $shell"
    
    print_colored "$GREEN" "âœ… Nockchain miner is now running in a screen session named 'nock'"
    echo ""
    print_colored "$CYAN" "ğŸ’¡ SCREEN SESSION COMMANDS:"
    print_colored "$CYAN" "   To attach to the session:  screen -r nock"
    print_colored "$CYAN" "   To detach from the session:      Press Ctrl+A, then D"
    print_colored "$CYAN" "   To stop the miner:         screen -S nock -X quit"
    
    return 0
}

# Run multiple nockchain miners in separate screen sessions
run_batch_nockchain() {
    # Check dependencies first
    check_dependencies
    
    local num_instances=$1
    
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘               STARTING MULTIPLE NOCKCHAIN MINERS                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    
    if ! command_exists screen; then
        print_colored "$RED" "âŒ screen is not installed. Cannot run nockchain in the background."
        return 1
    fi
    
    # Make sure nockchain is installed
    if [ ! -x "$INSTALL_DIR/nockchain" ]; then
        print_colored "$RED" "âŒ nockchain binary not found or not executable."
        print_colored "$YELLOW" "   Please run 'nockhelper install' first."
        return 1
    fi
    
    print_colored "$CYAN" "Starting $num_instances nockchain miner instances in separate screen sessions..."
    
    # Detect preferred shell
    local shell=$(detect_shell)
    
    # Environment variables for nockchain
    local env_vars="export RUST_LOG=\"info,nockchain=debug,nockchain_libp2p_io=info,libp2p=info,libp2p_quic=info\" && export MINIMAL_LOG_FORMAT=\"true\""
    
    # For Linux, set vm.overcommit_memory=1
    local os=$(detect_os)
    if [[ "$os" == "linux" ]]; then
        print_colored "$YELLOW" "Setting vm.overcommit_memory=1 for Linux..."
        sudo sysctl -w vm.overcommit_memory=1
    fi
    
    # Create directories and start instances
    for ((i=1; i<=$num_instances; i++)); do
        local instance_dir="$INSTALL_DIR/nock-$i"
        local screen_name="nock-$i"
        local binary_name="nock-$i"
        
        # Check if screen session already exists
        if screen -list | grep -q "$screen_name"; then
            print_colored "$YELLOW" "â„¹ï¸ nockchain instance $i is already running in screen session '$screen_name'"
            continue
        fi
        
        # Create instance directory if it doesn't exist
        if [ ! -d "$instance_dir" ]; then
            print_colored "$BLUE" "Creating directory for instance $i: $instance_dir"
            mkdir -p "$instance_dir"
        fi
        
        # Copy nockchain binary to instance directory and rename it
        print_colored "$BLUE" "Copying and renaming nockchain binary to $binary_name for instance $i..."
        cp "$INSTALL_DIR/nockchain" "$instance_dir/$binary_name"
        chmod +x "$instance_dir/$binary_name"
        
        # Create screen session for this instance with trap to ensure process cleanup
        print_colored "$GREEN" "Starting nockchain instance $i in screen session '$screen_name'..."
        
        # Create a wrapper script to handle cleanup when the screen session ends
        cat > "$instance_dir/start_nockchain.sh" << EOF
#!/bin/bash
# Wrapper script for nockchain instance $i

# Store process IDs
export MAIN_PID=\$$
echo "\$MAIN_PID" > "$instance_dir/.nock_${i}_pid"

# Function to clean up when the script exits
cleanup() {
    echo "Cleaning up nockchain instance $i..."
    
    # Get all child processes
    local children=\$(pgrep -P \$MAIN_PID 2>/dev/null || echo "")
    local grandchildren=""
    
    # For each child, get its children too
    for child in \$children; do
        local child_procs=\$(pgrep -P \$child 2>/dev/null || echo "")
        if [ -n "\$child_procs" ]; then
            grandchildren="\$grandchildren \$child_procs"
        fi
    done
    
    # Combine all processes
    local all_procs="\$children \$grandchildren"
    
    # Try graceful termination first
    if [ -n "\$all_procs" ]; then
        echo "Sending SIGTERM to child processes: \$all_procs"
        kill -15 \$all_procs 2>/dev/null || true
        sleep 2
        
        # Check if any processes still running
        local still_running=""
        for pid in \$all_procs; do
            if kill -0 \$pid 2>/dev/null; then
                still_running="\$still_running \$pid"
            fi
        done
        
        # If still running, force kill
        if [ -n "\$still_running" ]; then
            echo "Forcing termination of processes: \$still_running"
            kill -9 \$still_running 2>/dev/null || true
        fi
    fi
    
    # Also look for any processes with our specific binary name
    local binary_procs=\$(pgrep -f "$binary_name" || echo "")
    if [ -n "\$binary_procs" ]; then
        echo "Terminating $binary_name processes: \$binary_procs"
        kill -15 \$binary_procs 2>/dev/null || true
        sleep 1
        kill -9 \$binary_procs 2>/dev/null || true
    fi
    
    # Clean up PID file
    rm -f "$instance_dir/.nock_${i}_pid"
    
    echo "Cleanup completed."
}

# Cleanup when any signal is received
trap cleanup EXIT SIGINT SIGTERM

# Set environment variables
$env_vars

# Change to instance directory
cd "$instance_dir" 

# Clean up any previous data
rm -rf ./.data.nockchain .socket/nockchain_npc.sock

# Start the nockchain process
exec ./$binary_name --mining-pubkey $MINING_PUBKEY --mine --peer /ip4/95.216.102.60/udp/3006/quic-v1 --peer /ip4/65.108.123.225/udp/3006/quic-v1 --peer /ip4/65.109.156.108/udp/3006/quic-v1 --peer /ip4/65.21.67.175/udp/3006/quic-v1 --peer /ip4/65.109.156.172/udp/3006/quic-v1 --peer /ip4/34.174.22.166/udp/3006/quic-v1 --peer /ip4/34.95.155.151/udp/30000/quic-v1 --peer /ip4/34.18.98.38/udp/30000/quic-v1 --peer /ip4/96.230.252.205/udp/3006/quic-v1 --peer /ip4/94.205.40.29/udp/3006/quic-v1 --peer /ip4/159.112.204.186/udp/3006/quic-v1 --peer /ip4/217.14.223.78/udp/3006/quic-v1
EOF

        chmod +x "$instance_dir/start_nockchain.sh"
        
        # Start the screen session with the wrapper script
        screen -dmS "$screen_name" $shell -c "$instance_dir/start_nockchain.sh; exec $shell"
        
        print_colored "$GREEN" "âœ… Started nockchain instance $i in screen session '$screen_name'"
    done
    
    echo ""
    print_colored "$GREEN" "âœ… All nockchain instances are now running"
    echo ""
    print_colored "$CYAN" "ğŸ’¡ SCREEN SESSION COMMANDS:"
    print_colored "$CYAN" "   To list all sessions:       screen -ls"
    print_colored "$CYAN" "   To attach to a session:     screen -r nock-<id>"
    print_colored "$CYAN" "   To detach from a session:   Press Ctrl+A, then D"
    print_colored "$CYAN" "   To stop a miner instance:   screen -S nock-<id> -X quit"
    
    return 0
}

# Main function
main() {
    # If script is called directly from installation
    if [ "$(basename "$0")" != "nockhelper" ]; then
        install_nockchain
        return
    fi

    # Parse command line arguments
    local command=${1:-""}
    local arg2=${2:-""}
    
    case "$command" in
        install)
            install_nockchain
            ;;
        update)
            update_all
            ;;
        update-nockchain)
            update_nockchain
            ;;
        update-nockhelper)
            update_nockhelper
            ;;
        download)
            download_binaries
            ;;
        check)
            check_for_updates
            ;;
        uninstall)
            uninstall_nockchain
            ;;
        run)
            if [[ "$arg2" =~ ^[0-9]+$ ]]; then
                # If run is followed by a number, run batch instances
                run_batch_nockchain "$arg2"
            else
                # Otherwise, run a single instance
                run_nockchain
            fi
            ;;
        list)
            list_screen_sessions
            ;;
        cleanup)
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘                   CLEANING UP ZOMBIE PROCESSES                  â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            cleanup_all_zombies
            ;;
        del)
            if [ -z "$arg2" ]; then
                print_colored "$RED" "âŒ Please specify an instance ID or 'all'"
                display_help
                exit 1
            fi
            delete_nockchain_instances "$arg2"
            ;;
        status)
            check_status
            ;;
        help|--help|-h)
            display_help
            ;;
        "")
            # No command provided, show help
            display_help
            ;;
        *)
            print_colored "$RED" "âŒ Unknown command: $command"
            display_help
            exit 1
            ;;
    esac
}

# Run the main function
main "$@" 